<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Final Essay of Software Project Manage</title>
      <link href="/2022/06/02/projectManage/FinalEssay/"/>
      <url>/2022/06/02/projectManage/FinalEssay/</url>
      
        <content type="html"><![CDATA[<h1>Final Essay</h1><h2 id="Predictive-Life-Cycle">Predictive Life Cycle</h2><blockquote><p>The scope of the project can be articulated clearly and the schedule and cost can be predicted accurately.</p></blockquote><h3 id="Waterfall-life-cycle">Waterfall life cycle</h3><ul><li><p><strong>Apply Condition</strong></p><p>Risks must be tightly controlled, and changes must be limited after requirements are defined</p></li><li><p><strong>Example</strong></p><img src="/images/typora/image-20210616231125323.png" style="zoom:80%;"><p>As the project progresses, tasks and milestones form a waterfall structure like the picture above. <u>When one task or milestone is complete, the next one begins.</u> For example, there will be no deployment until the end of the test and revision phase.</p></li></ul><h3 id="Spiral-life-cycle">Spiral life cycle</h3><ul><li><p><strong>Apply Condition</strong></p><p>Project changes can be combined with reasonable cost increases or acceptable time delays</p></li><li><p><strong>Example</strong></p><img src="/images/typora/image-20210616231740627.png" style="zoom:80%;"><p>Usually, <u>some general models are used at the beginning</u> of the project, and <u>then additional stages are added</u> when some special risks are identified later in the project. Perhaps the most important feature of this model is its ability to <u>handle risks</u>.</p></li></ul><h3 id="Incremental-life-cycle">Incremental life cycle</h3><ul><li><p><strong>Apply Condition</strong></p><p>The incremental build life cycle model provides for progressive development  of operational software, with each release providing added capabilities.</p></li><li><p><strong>Example</strong></p><p><img src="/images/typora/image-20210616232700886.png" alt=""></p><p>Suppose we want to develop a web-based social network with the following functionalities;</p><p><strong>Component 1:</strong> Sign up and log in</p><p><strong>Component 2:</strong> Send Friend request</p><p><strong>Component 3:</strong> Accept friend request</p><p>We can successively add components. Each component undergoes the phases of requirements gathering and analysis, design, implementation, deployment, and maintenance. When the component is ready, we will deliver the component to the customer.</p></li></ul><h3 id="Prototyping-life-cycle">Prototyping life cycle</h3><ul><li><p><strong>Apply Condition</strong></p><p>This approach is often used in systems that involve a great deal of user interface design, or that automate previously manual functions.</p></li><li><p><strong>Example</strong></p><p><img src="/images/typora/image-20210617000349872.png" alt=""></p><p><strong>A) Rapid Throwaway Prototyping –</strong><br>In this method, the developed prototype is not necessarily part of the final accepted prototype. Customer feedback helps prevent unnecessary design errors, so the final prototype developed has a higher quality.</p><p><strong>B) Evolutionary Prototyping –</strong><br>In this method, the initially developed prototype is gradually improved on the basis of customer feedback until it is finally accepted. Compared with rapid one-off prototyping, it provides a better method that can save time and effort.</p><p><strong>C) Incremental Prototyping –</strong></p><p>In this approach, the final desired product is broken down into different prototypes and developed separately. Finally, when all the individual parts have been properly developed, the different prototypes are assembled into the final product in a predetermined order.</p><p><strong>D) Extreme Prototyping –</strong></p><p>This method is mainly used for web development.</p></li></ul><h2 id="Adaptive-Software-Development">Adaptive Software Development</h2><blockquote><p>Software requirements <strong>cannot be</strong> clearly expressed early in the life cycle, so software is developed using a less structured, flexible approach.</p></blockquote><h3 id="Scrum">Scrum</h3><ul><li><p><strong>Apply Condition</strong></p><p>The Scrum framework utilized mainly in following tasks</p><p>a. Delivering the complex product</p><p>b. Developing a complex product</p><p>c. Sustaining the complex product</p></li><li><p><strong>Example</strong></p></li></ul><p><img src="/images/typora/image-20210617002547112.png" alt=""></p><p>​Google is following the scrum within the team. Many years ago, the user interface of google was very simple where you can search whatever you want. But nowadays the features are really user centric and user friendly. They are following the scrum and their focus is to enhance the product creatively. They are tackling the complex problems in scrums rather than big deployments they are concentrating on small deployments.</p>]]></content>
      
      
      <categories>
          
          <category> 软件项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> 2021年的春天 </tag>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 10（Operating System）</title>
      <link href="/2022/05/09/operatingSystem/os-chapter10/"/>
      <url>/2022/05/09/operatingSystem/os-chapter10/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Scheduling-Multiprocessor">Chapter 10 Scheduling (Multiprocessor)</h2><p><strong>Classifications of Multiprocessor Systems</strong></p><p>•Loosely coupled or distributed multiprocessor, or cluster</p><p>•Functionally specialized processors</p><p>•Tightly coupled multiprocessor</p><h3 id="Grain-粒度">Grain(粒度)</h3><p><img src="/images/typora/image-20210617164911541.png" alt=""></p><p><strong>Independent Parallelism（无约束并行性）</strong></p><p>进程间没有显式的同步</p><p>•each user is performing a particular application</p><p>•because more than one processor is available, average response time to the users will be less</p><p><strong>Coarse and Very Coarse Grained Parallelism</strong></p><p>一组运行在a <strong>multiprogrammed</strong> uniprocessor（单处理器）的并发进程</p><p>–can be supported on a multiprocessor with little or no change to user software</p><p><strong>Medium-Grained Parallelism</strong></p><p>•Single application can be effectively implemented as a collection of <strong>threads</strong> within a single process</p><p><strong>Fine-Grained Parallelism</strong></p><p>•Represents a much more complex use of parallelism than is found in the use of threads</p><h3 id="Design-issues">Design issues</h3><p><strong>•assignment of processes to processors(把进程分配到处理器)</strong></p><p>需要决定static or dynamic</p><p>如果一个进程从被激活到完成，一直被分配给同一个处理器，那么就需要每个处理器维护一个专门的short-term queue, 使用专用处理器允许一种gang scheduling（组调度策略）</p><p>缺点：一个处理器空闲，另一个处理器积压很多工作，</p><ul><li><p>为防止这个情况, a common queue can be used， 所有的进程进入这个全局队列，然后调度到任何一个可用的处理器中</p></li><li><p>another option is dynamic load balancing</p></li></ul><p>Approaches</p><p>–Master/Slave</p><p>​操作系统的核心功能总是在某个特定的处理器上运行</p><p>​•Master is responsible for scheduling</p><p>​•Slave sends service request to the master</p><p>​•Conflict resolution is simplified because one processor has control of all memory and I/O resources</p><p>–Peer</p><p>​•Kernel can execute on any processor</p><p>​•Each processor does self-scheduling from the pool of available processes</p><p><strong>•actual dispatching of a process</strong></p><p><strong>•use of multiprogramming on individual processors</strong></p><h3 id="Process-Scheduling">Process Scheduling</h3><p>有很多个基于优先级的队列</p><p>a multi-server queuing</p><p>对于双处理器，调度原则不如在单处理器中重要</p><h3 id="Thread-Scheduling">Thread Scheduling</h3><p><strong>Load Sharing</strong></p><p>系统维护一个就绪线程的全局队列，每个处理器只要空闲就从队列中选择一个线程。</p><p>缺点</p><ul><li>处理器很多时，出现bottleneck</li><li>抢占线程不太可能在同一处理器上执行</li><li>it is unlikely that all of the threads of a program will gain access to processors at the same time</li></ul><p><strong>Gang Scheduling</strong></p><p>一组相关线程<strong>一对一</strong>对应到一组处理器上运行</p><p><strong>Dedicated Processor Assignment</strong></p><p>提供通过将线程分配给处理器定义的隐式调度</p><p>调度应用程序时，将其每个线程分配给一个处理器，该处理器将一直专用于该线程，直到应用程序运行到完成为止</p><p>•If a thread of an application is blocked waiting for I/O or for synchronization with another thread, then that thread’s processor remains idle</p><p>在具有数十或数百个处理器的高度并行系统中，处理器利用率不再像效率或性能指标那样重要</p><p>在程序的生命周期中完全避免进程切换应该会导致该程序的显著加速</p><p><strong>Dynamic Scheduling</strong></p><p>进程中的线程数可以在执行过程中更改</p><h3 id="Real-Time-Systems">Real-Time Systems</h3><p><strong>Hard and Soft Real-Time Tasks</strong></p><p>Hard必须在ddl之前 否则造成damage</p><p>Soft希望在ddl之前，之后完成也可以</p><p><strong>Periodic and Aperiodic Tasks</strong></p><p>周期性 非周期性</p><p><strong>Characteristics of real time systems</strong></p><ul><li><p>Determinism可确定性</p></li><li><p>Responsiveness可响应性</p><p>Determinism is concerned with how long an operating system delays before acknowledging an interrupt. Responsiveness is concerned with how long, after acknowledgment, it takes an operating</p><p>system to service the interrupt.</p></li><li><p>User control用户控制</p></li><li><p>Reliability可靠性</p></li><li><p>Fail-soft operation故障弱化操作</p></li></ul><h4 id="Deadline-Scheduling">Deadline Scheduling</h4><p>RMS 最短周期任务具有最高优先级</p><p><img src="/images/typora/image-20210620175406064.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 9（Operating System）</title>
      <link href="/2022/05/05/operatingSystem/os-chapter9/"/>
      <url>/2022/05/05/operatingSystem/os-chapter9/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-Scheduling-Uniprocessor">Chapter 9  Scheduling(Uniprocessor)</h2><p>这些调度表明了执行这些功能的相对时间比例</p><ul><li>Long-term Scheduling： 决定是否把进程添加到the pool of processes to be executed</li><li>Medium-term Scheduling: 决定是否把进程添加到the number of processes that are partially or fully in main memory</li><li>Short-term Scheduling: 决定下次执行那个就绪进程（ available process)</li><li>I/O Scheduling</li><li><img src="/images/typora/image-20210616115114706.png" alt=""></li></ul><h3 id="Short-Term-Scheduling">Short-Term Scheduling</h3><p><code>dispatcher</code></p><p>导致当前进程阻塞或抢占当前运行进程的事件发生时，调用Short-Term Scheduling</p><p>•Clock interrupts</p><p>•I/O interrupts</p><p>•Operating system calls</p><p>•Signals (e.g., semaphores)</p><p><strong>标准:performance</strong></p><p><img src="/images/typora/image-20210616120258623.png" alt=""></p><h3 id="Selection-Function">Selection Function</h3><p><strong>w</strong> = time spent in system so far, waiting</p><p><strong>e</strong> = time spent in execution so far</p><p><strong>s</strong> = total service time required by the process, including <em>e</em>; generally, this quantity must be estimated or supplied by the user</p><h3 id="Decision-Mode">Decision Mode</h3><p>preemptive/non-preemptive</p><p><img src="/images/typora/image-20210616135651148.png" alt=""></p><p><img src="/images/typora/image-20210616135742176.png" alt=""></p><p>•<strong>Turnaround Time</strong> (Tr) is service time + wait time</p><p>•<strong>Normalized Turnaround Time</strong> (Tr / Ts) – ratio to actual service time</p><p>–1.0 means no waiting</p><p>–2.0 means waiting as long as it took to execute</p><p>–Bigger values indicate additional wait time with respect to execution time</p><blockquote><p><strong>FCFS</strong></p><p>非抢占</p><p>first come first served</p><p>•When the current process finishes, the longest waiting process in the Ready queue is selected</p><p>•Performs much <u>better for long processes</u> than short ones</p><p>•Tends to <u>favor processor-bound processes over I/O-bound processes</u></p><p><strong>Round Robin</strong></p><p>抢占</p><p>Uses preemption based on a clock</p><p><strong>SPN</strong></p><p>Shortest Process Next</p><p>非抢占</p><p>下次选择预计处理时间最短的进程， 短进程会跳过长作业，跳到队列头</p><p>风险：只要持续不断提供更短的进程，长进程就会饥饿</p><p><strong>SRT</strong></p><p>Shortest Remaining Time</p><p>抢占</p><p>•Preemptive version of SPN</p><p>选择预期剩余时间最短的进程</p><p>性能比SPN好，相对于正在进行的长作业，短作业可被立即选择并运行</p><p><strong>HRRN</strong></p><p>非抢占</p><p>Highest Response Ratio Next</p><p><img src="/images/typora/image-20210616143037901.png" alt=""></p><p>•Chooses next process with the greatest ratio</p><p><img src="/images/typora/image-20210616143209528.png" alt=""></p><p><img src="/images/typora/image-20210616143607797.png" alt=""></p><p><strong>feedback</strong></p><p><img src="/images/typora/image-20210616144012899.png" alt=""></p><p><img src="/images/typora/image-20210616144022767.png" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 8（Operating System）</title>
      <link href="/2022/05/03/operatingSystem/os-chapter8/"/>
      <url>/2022/05/03/operatingSystem/os-chapter8/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Virtual-Memory">Chapter 8: Virtual Memory</h2><blockquote><p>虚拟<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98">内存</a>技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。</p></blockquote><p>Resident set: 进程执行的任何时候都在内存的部分</p><p>Thrashing（系统抖动）：Too much loading and unloading</p><p><strong>Principle of locality</strong> avoids thrashing</p><h3 id="Hardware-and-Control-Structures">Hardware and Control Structures</h3><h4 id="Support-Needed-for-Virtual-Memory">Support Needed for Virtual Memory</h4><p>•hardware must support paging and segmentation</p><p>•operating system must include software for managing the movement of pages and/or segments between secondary memory and main memory</p><h4 id="Paging">Paging</h4><p>每个进程有自己的page table</p><p><img src="/images/typora/image-20210608215445344.png" alt=""></p><p>P(present)表示是否存在于内存中</p><p>M(modified)表示相应页的内容从上次装入内存到现在是否已改变</p><h5 id="Translation-Lookaside-Buffer-TLB">Translation Lookaside Buffer(TLB)</h5><p>每次虚拟访问会引起两次物理内存访问：</p><ol><li>–one to fetch the page table entry</li><li>–one to fetch the data</li></ol><p>导致内存访问时间加倍</p><p>为了克服这个缺陷，most virtual memory schemes make use of a special high-speed cache called a <strong>translation</strong> <strong>lookaside</strong> <strong>buffer</strong></p><p><img src="/images/typora/image-20210609112059938.png" alt=""></p><p><img src="/images/typora/image-20210609112449940.png" alt=""></p><h5 id="Page-Size">Page Size</h5><ul><li><p>页越小，内部碎片越少。</p><p>但是，页越小，每个进程需要的页的数量就越多，这意味着更大的页表。</p><p>对于多道程序设计环境的大程序，活动进程的一部分页表在虚存而非内存中。</p><p>因此，there may be a double page fault for a single reference to memory:</p><p><strong>first</strong> to bring in the needed portion of the page table and <strong>second</strong> to bring in the process page.</p></li><li><p>the physical characteristics of most secondary-memory devices <u>favor a larger page size</u> (more efficient block transfer of data)</p></li></ul><p><img src="/images/typora/image-20210609113702869.png" alt=""></p><p><img src="/images/typora/image-20210609113742104.png" alt=""></p><h4 id="Segmentation">Segmentation</h4><blockquote><p>Segmentation allows the programmer to view memory as consisting of multiple address spaces or segments</p><p><strong>Advantages</strong></p><ul><li>simplifies handling of growing data structures</li><li>allows programs to be altered and recompiled independently</li><li>有助于进程内的空间共享</li><li>有助于保护</li></ul></blockquote><h4 id="Combined-Paging-and-Segmentation">Combined Paging and Segmentation</h4><p>用户的地址空间被分成许多段。每段依次分为许多固定大小的页，页的长度等于内存中页框大小</p><h4 id="Protection-and-Sharing">Protection and Sharing</h4><p>保护：Segmentation entries have a base address and length</p><p>共享：一个segment可能会在多个进程的段表中引用</p><h3 id="Operating-System-Software">Operating System Software</h3><p><img src="/images/typora/image-20210609144524944.png" alt=""></p><p>前两个主要取决于硬件平台</p><h4 id="Fetch-Policy">Fetch Policy</h4><p>决定某页何时换入内存</p><ul><li>demand paging(请求分页)<ul><li>只有当访问到某页中的一个单元时才将该页取入内存</li><li>进程首次启动时，会出现大量page fault, 取入越来越多的页之后，局部性原理表明大多数将来访问的页都是最近读取的页，因此在一段时间后错误会逐渐减少，缺页中断的数量会降到很低。</li></ul></li><li>prepaging(预先分页)<ul><li>读取的页并不是缺页中请求的页</li><li>一个进程的页连续存在secondary memory中，则一次读取许多连续的页比隔一段时间读取一页更有效</li><li>若大多数额外读取的页未引用到，则这个策略是低效的</li><li><img src="/images/typora/image-20210609150150474.png" alt=""></li></ul></li></ul><h4 id="Placement-Policy">Placement Policy</h4><p>决定一个process piece驻存在real memory的什么位置</p><p>•Important design issue in a segmentation system</p><p>•Paging or combined paging with segmentation placing is irrelevant because hardware performs functions with equal efficiency</p><h4 id="Replacement-Policy">Replacement Policy</h4><p>Deals with the selection of a page in main memory to be replaced when a new page must be brought in</p><p>目标：移出最近最不可能访问的页</p><p><strong>Frame Locking</strong></p><p>内存中某些页框可能是被锁定的</p><ul><li><p>kernel of the OS as well as key control structures are held in locked frames</p></li><li><p>I/O buffers and time-critical areas may be locked into main memory frames</p></li><li><p>locking is achieved by associating a lock bit with each frame</p></li></ul><p><strong>基本算法</strong></p><ul><li><p>Optional</p><p>置换下次访问距离当前时间最长的页（不可能实现）</p></li><li><p>Least Recently used(LRU)</p><p>置换最长时间未被引用的页</p><p>•Difficult to implement</p><p>–one approach is to tag each page with the time of last reference</p><p>this requires a great deal of overhead</p></li><li><p>First-in-first-out(FIFO)</p><p>•Treats page frames allocated to a process as a circular buffer</p></li><li><p>Clock</p><p>When a page is first loaded in memory or referenced, the <em>use bit</em> is set to 1</p><p><img src="/images/typora/image-20210609155309135.png" alt=""></p></li></ul><p><img src="/images/typora/image-20210609160305610.png" alt=""></p><p><img src="/images/typora/image-20210609160332873.png" alt=""></p><p><strong>Page Buffering</strong></p><p>VAX VMS方法</p><p>不丢弃置换出的页，而是把他们放到下面两表之一</p><p><img src="/images/typora/image-20210609162737247.png" alt=""></p><h4 id="Resident-Set-Management">Resident Set Management</h4><p>•The OS must decide how many pages to bring into main memory</p><p>–the smaller the amount of memory allocated to each process, the more processes can reside in memory</p><p>–small number of pages loaded <strong>increases page faults</strong></p><p>–<strong>beyond a certain size</strong>, further allocations of pages will <strong>not</strong> effect the page fault rate</p><blockquote><ul><li><p><strong>Fixed-allocation</strong></p><p>发生缺页中断，该进程的一页就必须被它所需要的页面置换</p></li><li><p><strong>Variable-allocation</strong></p><p><img src="/images/typora/image-20210610152311050.png" alt=""></p></li></ul></blockquote><h4 id="Replacement-Scope">Replacement Scope</h4><p>两种类型都是在没有空闲的page frame时由一个page fault激活的</p><ul><li><strong>global</strong>（considers all unlocked pages in main memory）</li><li><strong>local</strong>（仅在产生这次缺页的进程的驻留页中选择）</li></ul><p>全局置换策略实现简单，开销更小。</p><blockquote><p><strong>Fixed Allocation, Local Scope</strong></p><p>Necessary to decide ahead of time the amount of allocation to give a process</p><ul><li>If allocation is too small, there will be a high page fault rate</li><li>If allocation is too large, there will be too few programs in main memory.有很多空闲时间，并把大量时间花费在交换上。</li></ul></blockquote><blockquote><p><strong>Variable Allocation , Global Scope</strong></p><p>•OS maintains a list of free frames</p><p>•Free frame is added to resident set of process when a page fault occurs</p><p>•If no frames are available, the OS must choose a page currently in memory</p><p>•One way to counter potential problems is to use page buffering</p></blockquote><blockquote><p><strong>Variable Allocation</strong>, <strong>Local Scope</strong></p><p>•When a page fault occurs, select the page to replace from among the resident set of the process that suffers the fault</p><p>•Decision to increase or decrease a resident set size is based on the assessment of the likely future demands of active processes</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 7（Operating System）</title>
      <link href="/2022/05/02/operatingSystem/os-chapter7/"/>
      <url>/2022/05/02/operatingSystem/os-chapter7/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-7-Memory">Chapter 7: Memory</h2><h3 id="Memory-Management-Requirements">Memory Management Requirements</h3><h4 id="•Relocation">•Relocation</h4><ul><li><p>一开始不知道程序会在main memory的哪个区域</p></li><li><p>Active process需要能从main memory换入换出</p></li><li><p>a process must be placed in the same memory region when it is swapped back in would be limiting</p><p>所以我们要把进程 <strong>relocate</strong></p></li></ul><h4 id="•Protection">•Protection</h4><ul><li><p>Processes need to <u>acquire permission</u> to reference memory locations for reading or writing</p></li><li><p>必须在运行时检查进程产生的内存访问，以确保它们只访问分配给该进程的内存空间</p></li><li><p>Mechanisms that support relocation also support protection</p></li></ul><h4 id="•Sharing">•Sharing</h4><p>允许多个进程访问内存的同一部分（保护机制具有灵活性）</p><h4 id="•Logical-organization">•Logical organization</h4><ul><li>Memory is organized as <strong>linear</strong></li><li><strong>Segmentation</strong>（分段）来满足需求</li><li><strong>modules</strong> can be given different permissions</li></ul><h4 id="•Physical-organization">•Physical organization</h4><ul><li><p>main and secondary memory</p></li><li><p><strong>overlaying</strong>(覆盖) 来组织数据和程序</p></li><li><p>unknow</p></li></ul><h3 id="Sharing-Memory-Partitioning-fixed">Sharing Memory Partitioning(fixed)</h3><p><img src="/images/typora/image-20210607220945261.png" alt=""></p><blockquote><p>Disadvantages</p><p>•A program may be too big to fit in a partition</p><p>•Main memory utilization is inefficient</p><ul><li><strong>internal fragmentation</strong>: wasted space due to the block of data loaded being smaller than the partition</li></ul></blockquote><p><img src="/images/typora/image-20210607221205525.png" alt=""></p><blockquote><p>Disadvantages</p><p>•The number of partitions limits the number of active processes</p><p>•Small jobs will not utilize partition space efficiently</p><p>•Large partitions may be able to handle multiple small jobs</p></blockquote><h3 id="Dynamic-Partitioning">Dynamic Partitioning</h3><p>•Partitions are of variable length and number</p><p><img src="/images/typora/image-20210607222639393.png" alt=""></p><p><img src="/images/typora/image-20210607222706177.png" alt=""></p><p>As time goes on, memory becomes more and more fragmented, and memory utilization declines. This phenomenon is referred to as <strong>external fragmentation</strong></p><p>One technique for overcoming external fragmentation is **compaction 😗*操作系统不时地移动进程，使得进程占用的空间连续，使所有的空闲空间连成一片</p><h4 id="Placement-Algorithms">Placement Algorithms</h4><ul><li><p>Best fit: 大小最接近的</p></li><li><p>First fit: the first available block that is large enough</p></li><li><p>Next fit: the next available block that is large enough</p></li></ul><h3 id="Buddy-System">Buddy System</h3><p>Memory blocks are available of size 2<em>K</em> <em>words, L ≤ K ≤ U,</em> where</p><p>2<em>L</em>= smallest size block that is allocated</p><p>2U = largest size block that is allocated; generally 2U is the size of the entire memory available for allocation</p><h3 id="Address">Address</h3><p><img src="/images/typora/image-20210607225930231.png" alt=""></p><p><img src="/images/typora/image-20210607230801590.png" alt=""></p><h3 id="Paging">Paging</h3><p>Process is divided into small fixed-size chunks of the same size</p><p><img src="/images/typora/image-20210608164131998.png" alt=""></p><h4 id="Page-table">Page table</h4><ul><li>for each process</li><li>Contains the frame location for each page in the process</li><li>Used by processor to produce a physical address</li></ul><p>一个程序最多由$2^6=64$页组成，每页为1kb</p><p><img src="/images/typora/image-20210608165208119.png" alt=""></p><h3 id="Segmentation">Segmentation</h3><p>•A program can be subdivided into segments</p><ul><li><p>may <strong>vary in length</strong></p></li><li><p>there is a <strong>maximum length</strong></p></li></ul><p>•Addressing consists of two parts:</p><ul><li><p>segment number</p></li><li><p>an offset</p></li></ul><p>•Similar to dynamic partitioning</p><p>•Eliminates <strong>internal fragmentation</strong>， 但会产生外部碎片（进程被分为多个小块，外部碎片也会很小）</p><p>分段方案中，一个程序可以占据多个分区，并且这些分区不要求是连续的。</p><p>•Usually visible （Typically the programmer will assign programs and data to different segments）</p><p>–the principal inconvenience of this service is that the programmer must be aware of the maximum segment size limitation</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 6（Operating System）</title>
      <link href="/2022/05/01/operatingSystem/os-chapter6/"/>
      <url>/2022/05/01/operatingSystem/os-chapter6/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Deadlock">Chapter 6 Deadlock</h2><p>pthread_join: 阻塞当前的线程，直到另外一个线程运行结束</p><p><strong>Mutex</strong></p><p>•Used to guarantee that one thread “excludes” all other threads while it executes the critical section.</p><blockquote><p><strong>Deadlock</strong>: each process in the set is blocked awaiting an event that can only be triggered by another blocked process in the set</p></blockquote><h3 id="Resource-Categories">Resource Categories</h3><ul><li><p>Reusable : can be safely used by only one process at a time and is not depleted by that use</p></li><li><p>Consumable: one that can be created (produced) and destroyed (consumed)</p></li></ul><h3 id="Condition">Condition</h3><p>必要条件</p><ol><li><p>Mutual Exclusion</p></li><li><p>Hold-and-Wait: a process may hold allocated resources while awaiting assignment of others</p></li><li><p>No preemption(抢占)：no resource can be forcibly removed from a process holding it</p><p>第四个条件：Circular Wait 存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源</p></li></ol><p><img src="/images/typora/image-20210614170557646.png" alt=""></p><h3 id="Dealing-with-Deadlock">Dealing with Deadlock</h3><h4 id="Prevent">Prevent</h4><h4 id="Avoid">Avoid</h4><ul><li><p>Resource Allocation Denial：如果一个进程的增加资源请求会导致死锁，则不允许这一资源分配</p><p>•<strong>Safe state</strong> is one in which there is at least one sequence of resource allocations to processes that does not result in a deadlock</p><p>•<strong>Unsafe state</strong> is a state that is not safe</p></li><li><p>Process Initiation Denial: 如果一个进程的请求会导致死锁，则不启动该进程</p><p><img src="/images/typora/image-20210614175457301.png" alt=""></p><p>会产生死锁 因为四个进程都需要至少一个R1</p></li></ul><h4 id="Detect">Detect</h4><p>•Ignore any process not requesting more resources</p><h4 id="recovery">recovery</h4><ol><li>取消所有死锁进程</li><li>将每个死锁进程备份到一些先前定义的检查点，并重新启动所有进程</li><li>连续中止死锁进程，直到死锁不再存在</li><li>依次抢占资源，直到死锁不再存在</li></ol><p><img src="/images/typora/image-20210614181046402.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 5（Operating System）</title>
      <link href="/2022/04/29/operatingSystem/os-chapter5/"/>
      <url>/2022/04/29/operatingSystem/os-chapter5/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Concurrency">Chapter 5 : Concurrency</h2><p>并发会在三种context中出现</p><ol><li>Multiple Applications (允许多个活动在应用程序间动态共享处理器时间)</li><li>Structured Applications：•extension of modular design and structured programming</li><li>Operating System Structure：•OS themselves implemented as a set of processes or threads</li></ol><h3 id="Special-Machine-Instruction">Special Machine Instruction</h3><p>The only process that may enter its critical section is one that finds bolt equal to 0.</p><p>When a process leaves its critical section, it resets <em>bolt to 0</em></p><ul><li><p><strong>Compare and swap instruction</strong></p><p>等着的进程进入busy waiting或spin waiting, 只能等着permission。</p><p>The choice of process depends on which process happens to execute the compare &amp; swap instruction next.</p></li><li><p><strong>Exchange instruction</strong></p><p><em>Each process uses a local variable key that is initialized to 1.</em></p><p>通过把bolt置为1来避免其他进程进入临界区</p></li></ul><h4 id="Advantages">Advantages</h4><ol><li>share main memory</li><li>simple and easy to verify</li></ol><h4 id="Disadvantages">Disadvantages</h4><ol><li>Busy-waiting consumes processor time</li><li>Starvation</li><li>Deadlock</li></ol><h3 id="Semaphore-信号量">Semaphore(信号量)</h3><p>传送信号：semSignal(s)信号量加一</p><p>接收信号：semWait(s) 信号量减一</p><p>把信号量视为一个integer， 只定义了以下三个操作</p><p>1)May be initialized to a nonnegative integer value</p><p>2)The semWait operation decrements the value</p><p>3)The semSignal operation increments the value</p><p><img src="/images/typora/image-20210613155120781.png" alt=""></p><p>二元信号</p><p><img src="/images/typora/image-20210613155351835.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 4（Operating System）</title>
      <link href="/2022/04/16/operatingSystem/os-chapter4/"/>
      <url>/2022/04/16/operatingSystem/os-chapter4/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Threads">Chapter 4 : Threads</h2><p><img src="/images/typora/image-20210527121137006.png" alt=""></p><h3 id="Thread-Examples">Thread Examples</h3><p>•Foreground and background work</p><p>​–<em>one thread reading user input, another executing the commands and updating the spreadsheet; yet another making periodic backups</em></p><p>•Asynchronous processing(异步处理)</p><p><img src="/images/typora/image-20210527121344006.png" alt=""></p><p>​–<em>a thread performing periodic backups against power failures in a word-processor</em></p><p>•Speed of execution</p><p>​–independent threads can execute in parallel</p><p>•Modular program structure</p><p>​–different tasks/activities in a program may be implemented using different threads</p><p>•Client/Server Computing</p><blockquote><p>In an OS that supports threads, <u>scheduling and dispatching is done on a thread basis</u></p></blockquote><img src="/images/typora/image-20210527121642395.png" style="zoom:50%;"><h3 id="Thread-Execution-States">Thread Execution States</h3><ol><li><p><strong>Spawn</strong></p><p>when a new process is spawned, a thread for that process is also spawned. Subsequently, <u>a thread within a process may spawn another thread within the same process</u>, providing an instruction pointer and arguments for the new thread. The new thread is provided with its own register context and stack space and placed on the ready queue.</p></li><li><p><strong>Block</strong></p><p>When a thread needs to wait for an event, it will block (<u>saving its user registers, program counter, and stack pointers</u>). The processor may now turn to the execution of another ready thread in <u>the same or a different</u> process.</p></li><li><p><strong>Unblock</strong></p><p>When the event for which a thread is blocked occurs, the thread is moved to the Ready queue.</p></li><li><p><strong>finish</strong></p><p>When a thread completes, its register context and stacks are <u>deallocated.</u></p></li></ol><h3 id="Threads-分类">Threads 分类</h3><h4 id="ULT">ULT</h4><ul><li>All thread management is done by the application</li><li><u>内核不知道线程的存在</u>，并将进程作为一个单元进行调度，并分配一个单一的执行状态</li><li>Any application can be programmed to be multithreaded by using a <em><strong>threads library</strong></em> which contains code for <strong>creating</strong> and <strong>destroying</strong> threads, for passing messages and data between threads, for <strong>scheduling</strong> thread execution, and for saving and restoring thread contexts.</li></ul><h4 id="KLT">KLT</h4><ul><li>All of the work of <em>thread management</em> is done by the kernel</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 3（Operating System）</title>
      <link href="/2022/04/13/operatingSystem/os-chapter3/"/>
      <url>/2022/04/13/operatingSystem/os-chapter3/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-3-Process">Chapter 3 : Process</h2><h3 id="Process-Element">Process Element</h3><p>OS keep track of the process using process element</p><ul><li>Program Code(which may be shared with other processes that are executing the same program)</li><li>A set of data associated with that code</li></ul><p>while the program is executing,this process can be uniquely characterized by a number of elements, including:</p><ul><li><strong>Identifier</strong>: A unique identifier associated with this process, to distinguish it</li><li><strong>State</strong></li><li><strong>Priority</strong></li><li><strong>Program counter</strong>: The address of the next instruction in the program to be executed.</li><li><strong>Memory Pointer</strong></li><li><strong>I/O status information</strong></li><li><strong>Accounting</strong> <strong>information</strong>: May include the amount of processor time and clock time used, time limits, account numbers, and so on.</li></ul><h3 id="Process-States">Process States</h3><ul><li>Trace: by listing the sequence of instructions that execute for that process</li><li>Dispatcher(调度器）: <u>small program</u> that switches the processor from one process to another</li></ul><h3 id="Process-Execution">Process Execution</h3><h4 id="Two-state-Process-Model">Two-state Process Model</h4><p>at any time, a process is either being executed by a processor or not</p><blockquote><p>a process maybe in one of two states: <strong>Running</strong> or <strong>Not Running</strong></p></blockquote><p>From time to time, the currently running process will be interrupted and <strong>the dispatcher</strong> portion of the OS will <strong>select some other process to run</strong>. The former process moves from the <strong>Running state</strong> to the <strong>Not Running state</strong>, and one of the <strong>other processes</strong> moves to the <strong>Running state.</strong></p><ul><li><strong>Process control block</strong>: help OS keep track of the process, including current state and location in memory</li><li>Processes that are not running must be kept in some sort of queue, waiting their turn to execute.</li><li>A process that is interrupted is transferred to the queue of waiting processes.</li><li>if the process has completed or aborted, it is discarded (exits the system).</li><li>In either case, the dispatcher takes another process from the queue to execute.</li></ul><h4 id="Five-state-Process-Model">Five-state Process Model</h4><p>看ppt</p><h4 id="Suspended-Processes-挂起进程">Suspended Processes(挂起进程)</h4><ul><li>–involves moving part of all of a process from main memory to disk</li><li>–when <strong>none</strong> of the processes in main memory is in the <strong>Ready</strong> state, the OS <strong>swaps</strong> one of the <strong>blocked processes</strong> out on to <strong>disk</strong> into a <strong>suspend queue</strong>，The OS then <strong>brings in</strong> another process <strong>from the suspend queue</strong>, or it honors a new-process request. Execution then continues with the <strong>newly arrived process</strong>.</li></ul><p>characteristics</p><ol><li>The process is not immediately available for execution.</li><li>The process may or may not be waiting on an event</li><li>The process was placed in a suspended state by an agent: either itself, a parent process, or the OS, for the purpose of preventing its execution</li><li>The process may not be removed from this state until the agent explicitly orders the removal</li></ol><h4 id="Process-Description">Process Description</h4><p>In a multiprogramming environment, there are a number of processes (P 1 ,…, P n <em>) that have been created and exist in</em> virtual memory. Each process needs access to certain system resources, including the processor, I/O devices, and main memory.</p><p><img src="/images/typora/image-20210521173404017.png" alt=""></p><p>Process P 2 is also in main memory but is blocked waiting for an I/O device allocated to P 1 . Process P n has been swapped out and is therefore suspended.</p><h4 id="OS-Control-Table">OS Control Table</h4><p><img src="/images/typora/image-20210521174123992.png" alt=""></p><h5 id="Memory-Tables">Memory Tables</h5><ul><li>Allocation of main memory and secondary memory</li><li>protection attributes</li><li>information needed to manage virtual memory</li></ul><h5 id="I-O-Tables">I/O Tables</h5><ul><li>Status of the I/O operation</li><li>the source location on main memory</li></ul><h5 id="File-Tables">File Tables</h5><p>•Information may be maintained and used by a file management system in which case the OS has little or no knowledge of files</p><h5 id="Process-Tables-Control-Structure">Process Tables &amp; Control Structure</h5><ul><li>some reference to memory,  I/O, and files, directly or indirectly</li><li>OS must know:<ul><li>Process location</li><li>the attributes of the process that are necessary for its management</li></ul></li></ul><blockquote><p><strong>Process control block</strong></p><ul><li>Process <strong>identification</strong></li><li>Processor <strong>state</strong> information</li><li>Process <strong>control</strong> information</li></ul></blockquote><h4 id="Modes-of-Execution">Modes of Execution</h4><table><thead><tr><th>User Mode</th><th>System Mode</th></tr></thead><tbody><tr><td>less-privileged</td><td>–more-privileged mode</td></tr><tr><td>–user programs typically execute in this mode</td><td>–also referred to as control mode or kernel mode</td></tr><tr><td></td><td>–kernel of the operating system</td></tr></tbody></table><h4 id="Process-Creation">Process Creation</h4><ol><li><p><strong>Assign a unique process identifier to the new process.</strong></p><p><strong>a new entry is added to the primary process table</strong></p></li><li><p><strong>Allocate space for the process.</strong></p></li><li><p><strong>Initialize the process control block.</strong></p></li><li><p><strong>Set the appropriate linkages.</strong></p><p>如果操作系统以链表的形式维护每个调度队列，那么新进程必须放在就绪或就绪/暂停列表中。</p></li><li><p><strong>Create or expand other data structures.</strong></p></li></ol><h4 id="Mechanisms-for-Interrupting-Process-Execution">Mechanisms for Interrupting Process Execution</h4><ul><li><p>Interrupt</p><p>–clock interrupt</p><p>–I/O interrupt</p><p>–memory fault (external)</p><p>•Time slice : 进程在被中断之前所能执行的最大时间</p></li><li><p>Trap</p><p>在当前运行的进程中生成的错误或异常条件</p></li><li><p>Supervisor call</p><p>显式的请求 （call to an OS function)</p></li></ul><h5 id="Change-of-Process-State">Change of Process State</h5><ol><li>save the context of the processor</li><li>update the process control block</li><li>move the process control block of this process to <strong>the appropriate queue</strong></li><li><strong>select another process</strong> for execution</li><li>update the process control block <strong>of the process selected</strong></li><li>update memory management data structures</li><li>restore the context of the processor to that which existed at the time the selected process was last switched out</li></ol><h5 id="Mode-Switching">Mode Switching</h5><ul><li><p>No Interrupts</p><ul><li>进入取指令阶段，在当前进程中获取当前程序的下一条指令</li></ul></li><li><p>an Interrupt is pending the processor</p><ul><li><p>It sets the program counter to the starting address of an interrupt handler program.</p></li><li><p>It switches <strong>from user mode to kernel mode</strong> so that the interrupt processing</p><p>code may include privileged instructions.</p></li></ul></li></ul><h3 id="Execution-of-the-Operating-System">Execution of the Operating System</h3><p>the concept of <strong>process</strong> is considered to <strong>apply only to user programs</strong>. The o<strong>perating system code</strong> is executed as a <strong>separate entity</strong> that operates in privileged mode.</p><h4 id="Execution-Within-User-Processes">Execution <em>Within</em> User Processes</h4><p>中断一个用户程序，使用某些操作系统例程，然后恢复用户程序</p><p>during the critical time, the code that is executed in the user process is shared operating system code and not user code.</p><p><img src="/images/typora/image-20210526173517069.png" alt=""></p><p>The view is that the OS is primarily a collection of routines that the user calls to perform various functions, executed within the environment of the user’s process.</p><blockquote><p><strong>Advantage</strong>: A user program has been interrupted to employ some operating system routine, and then resumed, and all of this has occurred without incurring the penalty of two process switches.</p></blockquote><h4 id="Process-Based-Operating-System">Process-Based Operating System</h4><p>to implement the OS as a collection of system processes.</p><blockquote><p><strong>Advantage</strong></p><ul><li>It imposes a program design discipline that encourages the use of <em>a modular OS</em> with <u>minimal, clean interfaces between the modules.</u></li><li>some <u>noncritical operating system</u> functions are conveniently implemented as separate processes. the function can run at an assigned priority level and be interleaved with other processes under dispatcher control.</li><li>useful in a multiprocessor or multicomputer environment</li></ul></blockquote><h3 id="Unix-SVR4">Unix SVR4</h3><h4 id="Process-State">Process State</h4><ul><li><p>Uses the model where most of the OS executes within <u>the environment of a user process</u></p></li><li><p><strong>System processes</strong> run in kernel mode</p></li><li><p><strong>User</strong> <strong>Processes</strong></p><p>–operate in <u>user mode</u> to execute <u>user programs and utilities</u></p><p>–operate in <u>kernel mode</u> to execute <u>instructions that belong to the kernel</u></p><p>–enter kernel mode by <u>issuing a system call</u>, when an exception is generated, or when an interrupt occurs</p></li></ul><p><img src="/images/typora/image-20210527110548361.png" alt=""></p><p><img src="/images/typora/image-20210527110841248.png" alt=""></p><p>(Ready to Run, in Memory) and (Preempted) are essentially the same state, the distinction is made to emphasize the way in which the preempted state is entered.</p><p>When a process is running in kernel mode (as a result of a supervisor call, clock interrupt, or I/O interrupt), there will come a time <u>when the kernel has completed its work and is ready to return control to the user program</u>. At this point, the kernel may decide to <u>preempt the current process</u> in favor of one that is ready and of higher priority. In that case, the current process moves to the preempted state. However, for purposes of <u>dispatching,</u> those processes in the Preempted state and those in the (Ready to Run, in Memory) state <u>form one queue.</u></p><p>While a process is running in kernel mode, it may not be preempted!</p><p>TWO UNIQUE PROCESSES</p><ol><li><strong>Process</strong> <strong>0</strong> 系统启动时创建 it is predefined as a data structure loaded at boot time. It is the swapper process.</li><li>process 0 spawns <strong>process 1</strong>, referred to as the init process; all other processes in the system have <u>process 1 as an ancestor.</u></li></ol><p><img src="/images/typora/image-20210527112329006.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2（Operating System）</title>
      <link href="/2022/04/12/operatingSystem/os-chapter2/"/>
      <url>/2022/04/12/operatingSystem/os-chapter2/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2">Chapter 2</h2><blockquote><p><strong>OS</strong></p><ul><li>A program that <strong>controls</strong> the execution of <strong>application programs</strong></li><li>An <strong>interface</strong> between applications and hardware</li><li>MAIN Objectives<ol><li>convenience</li><li>efficiency</li><li>ability to evolve</li></ol></li></ul></blockquote><h3 id="OS-Services">OS Services</h3><p>•<strong>Program development</strong>: The OS provides a variety of facilities and services</p><p>•<strong>Program execution</strong>: A number of steps need to be performed to execute a program</p><p>•<strong>Access I/O devices</strong>: Each I/O device requires its own set of instructions</p><p>•<strong>Controlled access to files</strong>: For file access, the OS must reflect a detailed understanding</p><p>•<strong>System access</strong>: For shared or public systems, the OS controls access to the</p><p>system as a whole and to specific system resources.</p><p>•<strong>Error detection and response</strong></p><p>•Accounting: A good OS will collect usage statistics for various resources and monitor performance parameters</p><h3 id="KEY-INTERFACES">KEY INTERFACES</h3><img src="/images/typora/image-20210517155539695.png" style="zoom: 150%;"><h4 id="Instruction-set-architecture-ISA">Instruction set architecture (ISA)</h4><p>指令集体系结构(ISA): ISA定义了机器的指令集 (计算机可以执行的语言指令)</p><p>这个接口是边界在<strong>硬件和软件之间</strong>。</p><p>that both <strong>application programs</strong> and <strong>utilities</strong> may access the ISA directly.</p><h4 id="Application-binary-interface-ABI">Application binary interface (ABI)</h4><p>应用二进制接口(ABI): ABI定义了二进制的标准在程序可移植性。</p><p>ABI通过用户ISA将系统调用接口定义为系统中可用的操作系统、硬件资源和服务系统。</p><h4 id="Application-programming-interface-API">Application programming interface (API)</h4><p>The API gives a <strong>program access</strong> to the <strong>hardware resources</strong> and services available in a system through the user ISA supplemented with high-level language (HLL) library calls</p><h3 id="Operating-System-as-a-Resource-Manager">Operating System as a Resource Manager</h3><p>The OS, as a control mechanism is unusual in two respects:</p><p>• The OS functions in <strong>the same way</strong> as ordinary computer software; that is, it is</p><p><strong>a program</strong> <strong>or</strong> <strong>suite of programs</strong> executed by the processor.</p><p>• The OS frequently relinquishes(放弃) control and must <strong>depend on the processor</strong> to</p><p>allow it to regain control.</p><img src="/images/typora/image-20210517161851662.png" style="zoom:67%;"><p>处理器本身是一种资源，操作系统必须决定有多少处理器时间用于执行特定的用户程序</p><h3 id="Evolution-of-OS">Evolution of OS</h3><h4 id="Reason">Reason</h4><ol><li><strong>Hardware upgrades plus new types of hardware</strong></li><li><strong>New services</strong></li><li><strong>Fixes</strong>: Any OS has faults. These are discovered over the course of time and fixes are made.</li></ol><h4 id="Stages">Stages</h4><ol><li><h5 id="Serial-Processing-no-OS">Serial Processing(no OS)</h5></li><li><h5 id="Simple-Batch-批处理-Systems-（with-monitor">Simple Batch(批处理) Systems （with monitor)</h5><blockquote><p>•Monitor controls the sequence of events</p><p>•<em>Resident Monitor</em> is software always in memory</p><p>•Monitor reads in job and gives control. Job returns control to monitor</p></blockquote><p>Job Control Language (JCL)</p><p>What compiler to use, what data to use</p><p><strong>Modes of Operation</strong></p><p>Considerations of <u>memory protection and privileged instructions</u> lead to the concept of modes of operation.</p><ul><li><p><strong>User Mode</strong></p><p><strong>A user program</strong> executes in a user mode , in which <u>certain areas of memory are protected from the user’s use and in which certain instructions may not be executed.</u></p></li><li><p><strong>Kernel Mode</strong></p><p><strong>The monitor</strong> executes in kernel mode, in which <u>privileged instructions may be executed and in which protected areas of memory may be accessed.</u></p></li></ul></li><li><h5 id="Multi-programmed-Batch-Systems">Multi-programmed Batch Systems</h5><p>uniprogramming: The processor spends a certain amount of time executing, until it reaches an I/O instruction; it must then wait until that I/O instruction concludes before proceeding</p><p><img src="/images/typora/image-20210517164449901.png" alt=""></p><p>multiprogramming: When one job needs to wait for I/O, the processor can switch to the other job, which is likely not waiting for I/O</p><p><img src="/images/typora/image-20210517164606121.png" alt=""></p><p>•memory is expanded to hold three, four, or more programs and switch among all of them</p><p><strong>It is the central theme of modern operating systems.</strong></p></li><li><h5 id="Time-Sharing-Systems">Time Sharing Systems</h5><p>•Processor time is shared among multiple users</p><p>Multiple users simultaneously access the system through terminals</p></li></ol><p><img src="/images/typora/image-20210517164945321.png" alt=""></p><h3 id="Memory-Management">Memory Management</h3><h4 id="Memory">Memory</h4><ul><li><p>Virtual</p><p>A facility that allows programs to address memory from a logical point of view, without regard to the amount of main memory</p><ul><li><img src="/images/typora/image-20210517170141444.png" alt=""></li></ul></li><li><p>Paging</p><p>•Provides for a dynamic mapping between the virtual address used in the program and a real (or physical) address in main memory</p></li></ul><h3 id="Different-Architectural-Approaches">Different Architectural Approaches</h3><p><strong>Microkernel Architecture</strong></p><p>•Assigns only a few essential functions to the kernel</p><p><img src="/images/typora/image-20210517170705067.png" alt=""></p><h3 id="Fault-Tolerance">Fault Tolerance</h3><p>concepts</p><blockquote><p>–Reliability</p><p>​–<em>R(t）</em></p><p>​–defined as the probability of its correct operation up to time <em>t</em> given that the system was operating correctly at time <em>t</em>*=*<em>o</em></p><p>–Mean time to failure (MTTF)</p><p>​–mean(平均) time to repair (MTTR) is the average time it takes to repair or replace a faulty element</p><p>–Availability</p><p>​–defined as the time that the system is available to service users’ requests</p></blockquote><img src="/images/typora/image-20210517172011743.png" style="zoom:80%;">]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 1（Operating System）</title>
      <link href="/2022/04/09/operatingSystem/os-chapter1/"/>
      <url>/2022/04/09/operatingSystem/os-chapter1/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-1">Chapter 1</h2><p><strong>4 Components</strong> : <code>CPU</code> <code>Main Memory</code> <code>I/O Modules</code> <code>System Bus</code></p><h3 id="OS">OS</h3><p>•Exploits the hardware resources of one or more processors</p><p>•Provides a set of services to system users</p><p>•Manages secondary memory and I/O devices</p><h3 id="Interrupt">Interrupt</h3><p>Processor waits for IO device may cause waste use of processor</p><blockquote><p><strong>Class of Interrupts</strong></p><ul><li>Program: Generated by some condition that occurs as a result of an instruction execution, such as <u>arithmetic overflow</u>, <u>division by zero</u>…</li><li>Timer: Generated by a timer within the processor</li><li>I/O</li><li>Hardware failure: such as power failure or memory parity error.</li></ul></blockquote><img src="/images/typora/image-20210512114354725.png" style="zoom:80%;"><h4 id="Short-I-O-wait-Long-I-O-wait">Short I/O wait &amp; Long I/O wait</h4><p><strong>Short I/O wait</strong></p><p>4的等待时间比较短， 不够执行完2</p><p><img src="/images/typora/image-20210512114901323.png" alt=""></p><p><strong>Long I/O wait</strong></p><p>4的等待时间比较长，执行完2之后还在等</p><p><img src="/images/typora/image-20210512115013143.png" alt=""></p><h4 id="Multiple-Interrupts">Multiple Interrupts</h4><p><img src="/images/typora/image-20210512120328882.png" alt=""></p><blockquote><p>中断执行的程序更重要 例如 Y&gt;X&gt;User Program</p></blockquote><h3 id="Memory-Hierarchy">Memory Hierarchy</h3><p><strong>Major constraint</strong></p><ul><li>amount</li><li>speed</li><li>expense</li></ul><p><img src="/images/typora/image-20210512121119664.png" alt=""></p><h4 id="Principle-of-Locality-Memory">Principle of Locality &amp; Memory</h4><h5 id="Locality-局部性原理">Locality(局部性原理)</h5><p>•Memory references by the processor tend to cluster</p><p>CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</p><p><u>Over a long period of time,</u> the clusters in use change, <u>but over a short period of time</u>, the processor is primarily working with fixed clusters of memory references.</p><h5 id="Memory-Hierarchy-v2">Memory Hierarchy</h5><p>Data is organized so that the percentage of accesses to each successively(依次) lower level is substantially（显著） <strong>less</strong> than that of the level above</p><blockquote><p>Let level 2 memory contain all program instructions and data. The current clusters can be temporarily placed in level 1. From time to time, one of the clusters in level 1 will have to be swapped back to level 2 to make room for a new cluster coming in to level 1.</p></blockquote><h3 id="Cache-Memory">Cache Memory</h3><h4 id="Cache-principles">Cache principles</h4><ul><li><strong>Invisible</strong> to OS</li><li>Interacts with other memory management <strong>hardware</strong></li><li>Processor must access memory at least once per instruction cycle</li><li>Processor execution is limited by memory cycle time</li></ul><h4 id="Cache-Motivation">Cache Motivation</h4><img src="/images/typora/image-20210517111746580.png" style="zoom:80%;"><p>Cache中复制了一部分memory中的数据，当CPU想读数据时，先从cache里面找，如果没有，cache从main memory中读取相应的数据，然后再返回给processor，因为<strong>局部性原理</strong>，当 a block of data 被取到cache时，许多near future会用到的数据也会在这个block里</p><h4 id="Cache-Design">Cache Design</h4><h5 id="Cache-and-block-size">Cache and block size</h5><p><strong>cache size</strong>: cache可以缓存最大数据的大小</p><blockquote><p>small caches can have a significant impact on performance</p></blockquote><p><strong>block</strong> <strong>size</strong>: the unit of data exchanged between cache and main memory</p><blockquote><p>As block size increases, <strong>hit ratio</strong> 先上升（the principle of locality：被引用词附近的数据很可能在不久的将来被引用的可能性很高） 然后下降 （as the block becomes even bigger and the probability of using the newly fetched data becomes less than the probability of reusing the data that <strong>have to be moved out of the cache to make room for the new block.</strong>）</p></blockquote><h5 id="Mapping-Function">Mapping Function</h5><p>Two constraints</p><ol><li><p>when one block is read in, another may have to be replaced</p><p>尽量减少替换我们不久将需要的区块的可能性</p></li><li><p>the more flexible the mapping function,</p><ol><li>the more complex is the circuitry required to search the cache</li><li>the more scope we have to design a replacement algorithm to maximize the hit ratio</li></ol></li></ol><h5 id="Replacement-Algorithms">Replacement Algorithms</h5><ol><li><p>FIFO</p></li><li><p>Least Recently Used (LRU) Algorithm</p><p>replace a block that has been in the cache the longest with no references to it（<em>Hardware mechanisms</em>（硬件机制） are needed to identify the least-recently-used block）</p></li></ol><h5 id="I-O-techniques">I/O techniques</h5><p>当处理器遇到与I/O有关的指令时，它会通过向适当的I/O模块发出命令来执行该指令</p><p><strong>Programmed I/O</strong></p><p>the I/O module performs the requested action and then sets the appropriate bits in the I/O status register but takes <strong>no further action</strong> to alert the processor.</p><p>它不会中断处理器。因此，在调用I / O指令之后，处理器会定期检查I / O模块的状态，直到发现操作已完成。</p><p>As a result, the performance level of the entire system is severely degraded.</p><p><strong>Interrupt-Driven I/O</strong></p><p>(如上面说的interrupt的例子)</p><p>drawback</p><ol><li>The I/O transfer rate is limited by the speed with which the processor can test and service a device.</li><li>每次I/O transfer都必须执行许多指令</li></ol><p><strong>Direct Memory Access(DMA)</strong></p><p>🍶 When large volumes of data are to be moved</p><blockquote><p>The DMA function can be performed by a separate module on the system bus or it can be incorporated into an I/O module.</p></blockquote><p>processor issues a command to the DMA module containing:</p><p>•whether a read or write is <strong>requested</strong></p><p>•the <strong>address of the I/O device</strong> involved</p><p>•the <strong>starting location</strong> in memory to read/write</p><p>•the <strong>number of words</strong> to be read/written</p><ul><li>Transfers the entire block of data directly to and from memory <strong>without going through the processor</strong><ul><li>处理器将这个IO操作委托给DMA模块之后，继续其他工作。DMA模块将整个数据块(一次一个字)直接传输到或从内存中，而<u>不需要经过处理器</u>。当传输完成时，DMA模块向处理器发送一个中断信号。因此，处理器只在传输的<strong>开始和结束时</strong>涉及。</li><li>当需要处理器<strong>访问总线</strong>时，在DMA传输期间处理器执行得<strong>更慢</strong>。然而，对于<strong>多字I/O传输</strong>，DMA远比interrupt-driven或programmed I/O<strong>更有效</strong>。</li></ul></li></ul><h4 id="Multiprocessor-and-multicore-organization">Multiprocessor and multicore organization</h4><h5 id="Symmetric-multiprocessors">Symmetric multiprocessors</h5><ol><li><p>有两个或更多具有类似能力的<strong>类似处理器</strong>。</p></li><li><p>这些处理器<strong>共享相同的main memory</strong>和<strong>I/O facility</strong>，并通过bus或其他内部连接方案相互连接，这样每个处理器的<strong>memory access time大致相同</strong>。</p></li><li><p>所有处理器都<strong>共享对I/O设备</strong>的访问，要么通过相同的通道，要么通过为相同设备提供路径的不同通道。</p></li><li><p>所有处理器都可以执行<strong>相同的功能</strong>(因此有了对称这个术语)。</p></li><li><p>该系统由一个集成的操作系统控制，该操作系统在作业、任务、文件和程序之间提供交互数据元素的水平。</p></li></ol><p><strong>advantages</strong></p><ol><li>Performance: if work can be done in <strong>parallel</strong></li><li>Availability: the <strong>failure</strong> of a single processor <strong>does not halt the machine</strong></li><li>Incremental growth: an <strong>additional processor</strong> can be added to enhance performance</li><li>Scaling: vendors(供应商) can offer <strong>a range of products</strong> with different price and performance characteristics</li></ol><h5 id="Multicore-computers">Multicore computers</h5><p>Designers have found that the best way to improve performance to take advantage of advances in hardware is to put multiple processors and a substantial amount of cache memory on a single chip.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Mike的操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 6（Digital Design and Computer Architecture）</title>
      <link href="/2022/04/02/computerComposit/Chapter%206/"/>
      <url>/2022/04/02/computerComposit/Chapter%206/</url>
      
        <content type="html"><![CDATA[<h1><em><strong>Chapter 6</strong></em></h1><h2 id="Introduction">Introduction</h2><p>Computer performance depends on:<br><strong>– Processor performance</strong><br><strong>– Memory system performance</strong></p><h2 id="Memory-System-Performance">Memory System Performance</h2><p>Analysis</p><h3 id="Evaluation-Primary-Memory">Evaluation Primary Memory</h3><p>–<strong>3 Key characters ：Capacity,  speed and price</strong></p><p>• Price per bit， P=C/S    (C—price of memory，S—capacity（bits）)<br>• Larger capacity, faster speed --&gt; higher price</p><h3 id="Multi-layered-Memory">Multi-layered Memory</h3><p><strong>Memory</strong></p><p>speed: lower than CPU</p><p>capacity:   falls behind the need of software.</p><p><strong>To solve this</strong></p><p><img src="/images/typora/image-20201106110618367.png" alt=""></p><p><strong>Memory Hierarchy</strong></p><p><img src="/images/typora/image-20201106111153647.png" alt=""></p><h3 id="Locality">Locality</h3><h4 id="Temporal-Locality">Temporal Locality</h4><p>– Locality in <strong>time</strong><br>– If data used recently, likely to use it again soon<br>– <strong>How to exploit</strong>: keep recently accessed data in higher<br>levels of memory hierarchy(cache)</p><h4 id="Spatial-Locality">Spatial Locality</h4><p>– Locality in <strong>space</strong><br>– If data used recently, likely to use nearby data soon<br>– <strong>How to exploit</strong>: when access data, bring nearby data<br>into higher levels of memory hierarchy too(cache)</p><h2 id="cache">cache</h2><p><img src="/images/typora/image-20201106112818019.png" alt=""></p><p><strong>MAR</strong>: memory address register</p><p><strong>CAR</strong>: cache address register</p><p><strong>Hit</strong>: data found in that level of memory hierarchy</p><p><strong>Miss</strong>: data not found (must go to next level)</p><p><img src="/images/typora/image-20201106115714816.png" alt=""></p><img src="/images/typora/image-20201106120237191.png" style="zoom:67%;"><h3 id="Memory-Performance">Memory Performance</h3><p><strong>Tc</strong> : cache access time</p><p><strong>Tm</strong> : the time spent for transferring a main memory block to the cache</p><p><strong>Ta</strong> : average access time</p><p><strong>Average memory access time (AMAT)</strong>: average time for processor to access data</p><img src="/images/typora/image-20201106120929109.png"><h3 id="Cache-Terminology">Cache Terminology</h3><p><img src="/images/typora/image-20201106121543848.png" alt=""></p><h3 id="Direct-Mapped-Cache-Hardware">Direct Mapped Cache Hardware</h3><p>one bit for v (if the roll is empty , v=0)</p><p>set number : locate the role</p><p><img src="/images/typora/image-20201116091234050.png" alt=""></p><h3 id="N-Way-Set-Associative-Cache">N-Way Set Associative Cache</h3><p>Each memory address still maps to a specific set, but it can map to any one of the N blocks in the set.</p><p><img src="/images/typora/image-20201116092013402.png" alt=""></p><h3 id="Full-Associative-Cache">Full Associative Cache</h3><p>Conflict can be further reduced</p><p><em><strong>Larger blocks reduce compulsory misses through spatial locality</strong></em></p><h2 id="Virtual-Memory">Virtual Memory</h2><p>Virtual memory is much bigger  than physical one.</p><h3 id="Virtual-Address">Virtual Address</h3><ul><li><p>Programs use virtual addresses</p></li><li><p>Entire virtual address space stored on a hard drive</p></li><li><p>Subset of virtual address data in DRAM</p></li><li><p>CPU translates virtual addresses into physical addresses (DRAM addresses)</p></li><li><p>Data not in DRAM fetched from hard drive</p></li></ul><h3 id="Memory-Protection">Memory Protection</h3><p>– Each program has own virtual to physical mapping</p><p>– Two programs can use same virtual address for different data</p><p>– Programs don’t need to be aware others are running</p><p>– One program (or virus) can’t corrupt memory used by another</p><p><img src="/images/typora/image-20201123084228456.png" alt=""></p><ul><li><p>Page size : amount of memory transferred from hard disk to DRAM at once</p></li><li><p>Address translation :  determining physical address from virtual address</p></li><li><p>Page table: lookup table used to translate virtual addresses to physical addresses</p></li><li><p><img src="/images/typora/image-20201123090531972.png" alt=""></p><p>Virtual page number 的最后一位是2，所以在表中从下往上对应2位置（0，1，2…)</p></li></ul><h2 id="Memory-Mapped-I-O">Memory-Mapped I/O</h2><h3 id="Hardware">Hardware</h3><ul><li>Address Decoder</li><li>I/O Registers</li><li>ReadData Multiplexer</li></ul><p><img src="/images/typora/image-20201123091956190.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 5（Digital Design and Computer Architecture）</title>
      <link href="/2022/03/28/computerComposit/Chapter%205/"/>
      <url>/2022/03/28/computerComposit/Chapter%205/</url>
      
        <content type="html"><![CDATA[<h1><em>Chapter 5</em></h1><h2 id="Performance-Analysis">Performance Analysis</h2><p><strong>•Definitions:</strong></p><p>–CPI: Cycles per instruction</p><p>–clock period: seconds/cycle</p><p>–IPC: instructions per cycle</p><h3 id="Throughput-vs-Response-Time">Throughput vs Response Time</h3><p><strong>•Response time</strong> (execution time) – the time between the start and the completion of a task</p><p>–Important to <strong>individual users</strong></p><p><strong>•Throughput</strong> (bandwidth) – the total amount of work done in a given time</p><p>–Important to <strong>data center managers</strong></p><h3 id="CPU-Time">CPU Time</h3><img src="/images/typora/image-20201101213057437.png" style="zoom:67%;"><img src="/images/typora/image-20201101214021161.png" style="zoom:80%;"><h3 id="CPU-Clocking">CPU Clocking</h3><p><img src="/images/typora/image-20201101213243461.png" alt=""></p><p>Clock period(周期）: duration of a clock cycle</p><p>250ps = 0.25ns = 250×10–12s</p><p>Clock frequency (频率): cycles per second</p><p>4.0GHz = 4000MHz = 4.0×109Hz</p><h3 id="Instruction-Count-and-CPI">Instruction Count and CPI</h3><img src="/images/typora/image-20201101214021161.png" style="zoom:80%;"><p><strong>Weighted average CPI</strong></p><img src="/images/typora/image-20201101214218165.png" style="zoom:67%;"><p>e.g<img src="/images/typora/image-20201101214349315.png" style="zoom:67%;"></p><h2 id="Single-Cycle-Processor"><strong>Single-Cycle Processor</strong></h2><h3 id="state-elements">state elements</h3><p>PC: program counter</p><p><img src="/images/typora/image-20201102082551097.png" alt=""></p><h3 id="I-type">I type</h3><p><img src="/images/typora/image-20201102082913007.png" alt=""></p><h2 id="Multicycle-Processor"><strong>Multicycle</strong> <strong>Processor</strong></h2><p><strong>What’s improved</strong></p><p>read, write or alu operation in one cycle</p><p>每个周期内,完成一次read或write操作,或ALU操作;</p><p>different instruction adopts different cycle combination</p><p>不同指令使用不同的周期组合;</p><p>only one adder and one memory, shared in different cycles</p><p>仅需要一个adder,在不同周期重复使用;</p><p>一个memory, 在不同周期使用.</p><p><strong>Instruction cycle</strong></p><p><strong>machine cycle（CPU周期）</strong></p><p><img src="/images/typora/image-20201102084308868.png" alt=""></p><h3 id="State-Elements">State Elements</h3><p><img src="/images/typora/image-20201102084750829.png" alt=""></p><h2 id="Pipelined-Processor"><strong>Pipelined Processor</strong></h2><h3 id="•Divide-single-cycle-processor-into-5-stages">•Divide single-cycle processor into 5 stages:</h3><p>–Fetch</p><p>–Decode</p><p>–Execute</p><p>–Memory</p><p>–Writeback</p><p><img src="/images/typora/image-20201102093807227.png" alt=""></p><h3 id="Pipelined-Processor-Abstraction"><strong>Pipelined Processor Abstraction</strong></h3><p>(there is no building block conflict)</p><p><img src="/images/typora/image-20201102094607594.png" alt=""></p><h3 id="Pipelined-Datapath">Pipelined Datapath</h3><p><img src="/images/typora/image-20201102095551430.png" alt=""></p><p><em><strong>Same control unit as single-cycle processor</strong></em></p><h3 id="Harzard">Harzard</h3><h4 id="Data-hazard"><strong>Data hazard:</strong></h4><p>register value not yet written back to register file</p><h5 id="Data-forwarding"><strong>Data forwarding</strong></h5><p><img src="/images/typora/image-20201102101251458.png" alt=""></p><h5 id="Stalling">Stalling</h5><p><img src="/images/typora/image-20201102101418003.png" alt=""></p><h4 id="Control-Harzard">Control Harzard</h4><p>next instruction not decided yet (caused by branches)</p><p><img src="/images/typora/image-20201102101609724.png" alt=""></p><h5 id="Early-Branch-Resolution">Early Branch Resolution</h5><h5 id="Branch-Prediction">Branch Prediction</h5><h2 id="Exceptions"><strong>Exceptions</strong></h2><h2 id="Advanced-Microarchitecture"><strong>Advanced Microarchitecture</strong></h2>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 4（Digital Design and Computer Architecture）</title>
      <link href="/2022/03/10/computerComposit/Chapter%204/"/>
      <url>/2022/03/10/computerComposit/Chapter%204/</url>
      
        <content type="html"><![CDATA[<h1><em>Chapter 4</em></h1><h2 id="Assembly-Language">Assembly Language</h2><p><strong>MIPS</strong> architecture</p><h3 id="Architecture-Design-Principles">Architecture Design Principles</h3><p><strong>1.Simplicity favors regularity</strong></p><p>•Consistent instruction format</p><p>•Same number of operands (two sources and one destination)</p><p>•easier to encode and handle in hardware</p><p><strong>2.Make the common case fast</strong></p><p>•Only simple, commonly used instructions</p><p>•Hardware to decode and execute instructions can be simple, small, and fast</p><p>•More complex instructions (that are less common) performed using multiple simple instructions</p><p>•MIPS is a <strong>reduced instruction set computer</strong> <strong>(RISC)</strong>, with a small number of simple instructions</p><p>•Other architectures, such as Intel’s x86, are <strong>complex instruction set computers</strong> <strong>(CISC)</strong></p><p><strong>3.Smaller is faster</strong></p><p>•MIPS includes only a small number of registers</p><p><strong>4.Good design demands good compromises</strong></p><h4 id="Instruction">Instruction</h4><p><em>MIPS assembly code</em></p><p>Addition: add a , b , c</p><p>•add: <em><strong>mnemonic</strong></em> indicates operation to perform</p><p>•b,c:  <em><strong>source operands</strong></em> (on which the operation is performed)</p><p>•a: <em><strong>destination operand</strong></em> (to which the result is written)</p><p>Subtraction: sub a , b, c</p><p>Multiple Instructions: add t,b,c   # t = b + c</p><h3 id="Operands">Operands</h3><h4 id="Registers">-Registers</h4><p>•MIPS has 32 32-bit registers</p><p>•Registers are faster than memory</p><p>•MIPS called “32-bit architecture” because it operates on 32-bit data</p><p>MIP Register Set</p><p><img src="/images/typora/image-20201026195551476.png" alt=""></p><ul><li><p>$ before name</p></li><li><p>$0 holds constant value 0</p></li><li><p><em><strong>saved registers</strong></em>, $s0-$s7, used to hold variables</p></li><li><p><em><strong>temporary registers</strong></em>, $t0 - $t9, used to hold intermediate values during a larger computation</p><p>e.g.</p><p>a = b+c</p><p><strong>MIPS assembly code:</strong>       # $s0 = a, $s1 = b, $s2 = c</p><p>​                                              add $s0, $s1, $s2</p></li></ul><h4 id="Memory">-Memory</h4><p>•Memory is large, but slow</p><p>•Commonly used variables kept in registers</p><h5 id="Word-Addressable-Memory"><strong>Word-Addressable Memory</strong></h5><p><img src="/images/typora/image-20201026200311280.png" alt=""></p><p>1.<em>Reading Word-Addressable Memory</em></p><p>​    •<em>load word</em> (lw)</p><p>​    lw $s0, 5($t1)</p><p>​    –add <em>base address</em> ($t1) to the <em>offset</em> (5)</p><p>​    –address = ($t1 + 5)</p><p>​    –$s0 holds the value at address ($t1 + 5)</p><p><em>2.Writing Word-Addressable Memory</em></p><p>​    • <em>store word</em> (sw)</p><p>​    sw $t4, 0x7($0)</p><p>\    # write the value in $t4</p><p>​     # to memory word 7</p><h5 id="Byte-Addressable-Memory">Byte-Addressable Memory</h5><p>Each data byte has unique address</p><p>32-bit word = 4 bytes, so word address increments by 4</p><p><img src="/images/typora/image-20201026201913906.png" alt=""></p><p>The address of a memory word must now be multiplied by 4 !!!</p><p><strong>MIPS is byte-addressed, not word-addressed！！！</strong></p><h5 id="Big-Endian-Little-Endian-Memory">Big-Endian &amp; Little-Endian Memory</h5><h4 id="Constants-also-called-immediates">-Constants(also called immediates)</h4><p><img src="/images/typora/image-20201026220732541.png" alt=""></p><h2 id="Machine-Language">Machine Language</h2><p>1’s and 0’s</p><p>•3 instruction formats:</p><h4 id="–R-Type-register-operands">–<strong>R-Type:</strong> register operands</h4><p><strong>•3 register operands:</strong></p><p><strong>–rs, rt</strong>:  source registers</p><p><strong>–rd</strong>: destination register</p><p><strong>•Other fields:</strong></p><p><strong>–op:</strong>  the <em>operation code</em> or <em>opcode</em> (0 for R-type instructions)</p><p><strong>–funct:</strong>  the <em>function</em></p><p><strong>–shamt:</strong>  the <em>shift amount</em> for shift instructions, otherwise it’s 0</p><p><img src="/images/typora/image-20201026221218292.png" alt=""></p><h4 id="–I-Type-immediate-operand">–<strong>I-Type:</strong> immediate operand</h4><p>•3 operands:</p><p>–<strong>rs, rt</strong>:  register operands</p><p>–<strong>imm</strong>: 16-bit two’s complement immediate</p><p><strong>•Other fields</strong>:</p><p><strong>–op:</strong>  the opcode</p><p>–Simplicity favors regularity: all instructions have opcode</p><p>–Operation is completely determined by opcode</p><p><img src="/images/typora/image-20201026222441666.png" alt=""></p><h4 id="–J-Type-for-jumping">–<strong>J-Type:</strong> for jumping</h4><p>•26-bit address operand (addr)</p><p>•Used for jump instructions (j)</p><p><img src="/images/typora/image-20201026222607615.png" alt=""></p><h3 id="Power-of-the-Stored-Program">Power of the Stored Program</h3><p><img src="/images/typora/image-20201028170932815.png" alt=""></p><h2 id="Programming">Programming</h2><h3 id="Logical-Instructions">Logical Instructions</h3><ul><li><p>and(useful for <strong>masking</strong> bits): 0xF234012F AND 0x000000FF = 0x0000002F</p></li><li><p>or(useful for <strong>combining</strong> bit fields):0xF2340000 OR 0x000012BC = 0xF23412BC</p></li><li><p>nor:(useful for <strong>inverting</strong> bits): A NOR $0 = NOT A</p><p>(MIP不提供NOT指令)</p><p>andi,ori,xori</p><p><img src="/images/typora/image-20201028172236544.png" alt=""></p></li></ul><h3 id="Shift-Instructions">Shift Instructions</h3><p>•<strong>sll</strong>: shift left logical</p><p>–Example:** sll $t0, $t1, 5      # $t0 &lt;= $t1 &lt;&lt; 5</p><p>•<strong>srl</strong>: shift right logical</p><p>–Example: srl $t0, $t1, 5      # $t0 &lt;= $t1 &gt;&gt; 5</p><p>•<strong>sra</strong>: shift right arithmetic</p><p>–Example: sra $t0, $t1, 5     # $t0 &lt;= $t1 &gt;&gt;&gt; 5</p><p>•<strong>sllv:</strong> shift left logical variable</p><p>–Example: sllv $t0, $t1, $t2    # $t0 &lt;= $t1 &lt;&lt; $t2</p><p>•<strong>srlv</strong>: shift right logical variable</p><p>–Example: srlv $t0, $t1, $t2    # $t0 &lt;= $t1 &gt;&gt; $t2</p><p>•<strong>srav</strong>: shift right arithmetic variable</p><p>–Example: srav $t0, $t1, $t2    # $t0 &lt;= $t1 &gt;&gt;&gt; $t2</p><h3 id="Generating-Constants">Generating Constants</h3><ul><li><p>16-bit constants</p><p><img src="/images/typora/image-20201028190354808.png" alt=""></p></li><li><p>32-bit constants (lui + ori)</p><p><img src="/images/typora/image-20201028191032717.png" alt=""></p></li></ul><p>lui stands for  <em>load upper immediate</em></p><h3 id="Multiplication-Division">Multiplication, Division</h3><ul><li><p>Special registers: lo , hi</p></li><li><p>32x32 multiplication = 64 bit result</p><p>–mult $s0, $s1</p><p>–Result in {hi, lo}</p></li><li><p>32/32  division = 32 bit quotient,remainder</p><p>–div $s0, $s1</p><p>–Quotient in lo</p><p>–Remainder in hi</p></li><li><p>Moves from lo/hi special registers</p><p>–mflo $s2</p><p>–mfhi $s3</p></li></ul><h3 id="Branching">Branching</h3><p>•Types of branches:</p><p>–<strong>Conditional</strong></p><p>•branch if equal (beq)</p><p>•branch if not equal (bne)</p><p>–<strong>Unconditional</strong></p><p>•jump (j)</p><p>•jump register (jr)</p><p>•jump and link (jal)： is similar to j，but is used by procedures to save a return address</p><h4 id="Conditional-Branching-beq">Conditional Branching(beq)</h4><p><img src="/images/typora/image-20201028193117638.png" alt=""></p><h4 id="The-Branch-Not-Taken-bne">The Branch Not Taken(bne)</h4><p><img src="/images/typora/image-20201028193037720.png" alt=""></p><h4 id="Unconditional-Branching-j">Unconditional Branching(j)</h4><p><img src="/images/typora/image-20201028193326144.png" alt=""></p><h4 id="Unconditional-Branching-jr">Unconditional Branching (jr)</h4><p><img src="/images/typora/image-20201028193451123.png" alt=""></p><p>jr is an R-type instruction</p><h3 id="If-Statement">If Statement</h3><p><img src="/images/typora/image-20201028194827473.png" alt=""></p><h3 id="If-Else-Statement">If/Else Statement</h3><p><img src="/images/typora/image-20201026084938319.png" alt=""></p><h3 id="While-loops">While loops</h3><p><img src="/images/typora/image-20201026085009737.png" alt=""></p><h3 id="For-loops">For loops</h3><p><img src="/images/typora/image-20201028200120960.png" alt=""></p><h3 id="Less-Than-Comparison">Less Than Comparison</h3><p><img src="/images/typora/image-20201028200300388.png" alt=""></p><p>slt相当于boolean</p><h3 id="Arrays">Arrays</h3><ul><li><p>Base address(address of the first element)</p></li><li><p><em><strong>first step</strong></em>: load base address into a register</p><p>address依次向上加4</p></li></ul><h4 id="Accessing-Arrays">Accessing Arrays</h4><p>​    # array base address = $s0</p><p>​    lui $s0, 0x1234     # 0x1234 in upper half of $S0</p><p>​    ori $s0, $s0, 0x8000   # 0x8000 in lower half of $s0</p><p>​    lw  $t1, 0($s0)     # $t1 = array[0]</p><p>​    sll $t1, $t1, 1     # $t1 = $t1 * 2</p><p>​    sw  $t1, 0($s0)     # array[0] = $t1</p><p>​                   ⬇️</p><p>​     get the address of array[1] (array[0]的地址加4)</p><p>​                   ⬇️</p><p>​    lw  $t1, 4($s0)     # $t1 = array[1]</p><p>​    sll $t1, $t1, 1     # $t1 = $t1 * 2</p><p>​    sw  $t1, 4($s0)     # array[1] = $t1</p><h4 id="Arrays-using-For-Loops">Arrays using For Loops</h4><p><strong>// C Code</strong></p><p>int array[1000];</p><p>int i;</p><p>for (i=0; i &lt; 1000; i = i + 1)</p><p>array[i] = array[i] * 8;</p><p>#<strong>MIP</strong></p><p># initialization code</p><p>lui $s0, 0x23B8    # $s0 = 0x23B80000</p><p>ori $s0, $s0, 0xF000  # $s0 = 0x23B8F000</p><p>addi $s1, $0, 0     # i = 0</p><p>addi $t2, $0, 1000   # $t2 = 1000</p><p>loop:</p><p>slt $t0, $s1, $t2   # i &lt; 1000?</p><p>beq $t0, $0, done   # if not then done</p><p>sll $t0, $s1, 2    # $t0 = i * 4 (byte offset)</p><p>add $t0, $t0, $s0   # address of array[i]</p><p>lw  $t1, 0($t0)    # $t1 = array[i]</p><p>sll $t1, $t1, 3    # $t1 = array[i] * 8</p><p>sw  $t1, 0($t0)    # array[i] = array[i] * 8</p><p>addi $s1, $s1, 1    # i = i + 1</p><p>j  loop        # repeat</p><p>done:</p><h4 id="Using-lb-and-sb-to-Access-A-Character-Array">Using lb and sb to Access A Character Array</h4><img src="/images/typora/image-20201029225917441.png" style="zoom:80%;"><img src="/images/typora/image-20201029225937401.png" style="zoom:80%;"><h3 id="Function-calls">Function calls</h3><ul><li><p>Caller: calling function</p><p>–passes <strong>arguments</strong> to callee</p><p>–jumps to callee</p></li><li><p>Callee: called function</p><p>–<strong>performs</strong> the function</p><p>–<strong>returns</strong> result to caller</p><p>–<strong>returns</strong> to point of call</p><p>–<strong>must not overwrite</strong> registers or memory needed by caller</p><img src="/images/typora/image-20201026094634751.png" style="zoom: 80%;"></li></ul><h3 id="Stack">Stack</h3><p>•last-in-first-out (LIFO) queue</p><p>•<strong>Expands</strong> uses more memory when more space needed</p><p>•<strong>Contracts</strong> uses less memory when the space is no longer needed</p><p><strong>stack pointer($sp)</strong>：points to top of the stack</p><p><img src="/images/typora/image-20201029232529393.png" alt=""></p><h2 id="Addressing-Modes">Addressing Modes</h2><p>how to address operands</p><ul><li><p>Register Only</p><p>Operands found in registers</p><p>–<strong>Example:</strong> add $s0, $t2, $t3</p><p>–<strong>Example:</strong> sub $t8, $s1, $0</p></li><li><p>Immediate</p><p>•16-bit immediate used as an operand</p><p>–<strong>Example:</strong> addi $s4, $t5, -73</p><p><strong>Example:</strong> ori $t3, $t7, 0xFF</p></li><li><p>Base Addressing</p><p>base address + sign-extended immediate</p><p>–<strong>Example:</strong> lw $s4, 72($0)</p><p>•address = $0 + 72</p><p>–<strong>Example:</strong> sw $t2, -25($t1)</p><p>•address = $t1 - 25</p></li><li><p>PC-Relative Addressing(branch and jump)</p><p>e.g.</p></li><li><p>Pseudo Direct Addressing</p></li></ul><h2 id="How-to-Compile-Run-a-Program">How to Compile &amp; Run a Program</h2><p><img src="/images/typora/image-20201101211213441.png" alt=""></p><h3 id="MIPS-Memory-Map">MIPS Memory Map</h3><p><img src="/images/typora/image-20201101210828189.png" alt=""></p><h2 id="Odds-and-Ends">Odds and Ends</h2><p>•Pseudoinstructions(伪指令)</p><p>•Exceptions</p><p>•Signed and unsigned instructions</p><p>•Floating-point instructions（浮点指令）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 3（Digital Design and Computer Architecture）</title>
      <link href="/2022/03/01/computerComposit/Chapter%203/"/>
      <url>/2022/03/01/computerComposit/Chapter%203/</url>
      
        <content type="html"><![CDATA[<h1><em><strong>Chapter 3</strong></em></h1><h2 id="Sequential-Logic-Circuits">Sequential Logic Circuits</h2><ul><li>Give sequence to events</li><li>Have memory(short-term)</li><li>Use feedback from output to input to store information</li></ul><h3 id="State-Elements">State Elements</h3><ul><li>Bistable circuit</li><li>SR Latch</li><li>D Latch</li><li>D Flip-flop</li></ul><h2 id="Latch-and-Flip-flop">Latch and Flip-flop</h2><h3 id="Bistable-Circuit">Bistable Circuit</h3><img src="/images/typora/image-20201213165642836.png" style="zoom:80%;"><h3 id="SR-Latch">SR Latch</h3><img src="/images/typora/image-20201213165914154.png" style="zoom:80%;"><h3 id="D-Latch">D Latch</h3><p><strong>(Split value and time)</strong></p><img src="/images/typora/image-20201220114729268.png" style="zoom: 50%;"><h4 id="D-Latch-internal-circuit">D Latch internal circuit</h4><img src="/images/typora/image-20201220114949394.png" style="zoom:67%;"><h3 id="D-Flip-Flop">D Flip-Flop</h3><h4 id="D-Flip-Flop-Internal-Circuit">D Flip-Flop Internal Circuit</h4><p><img src="/images/typora/image-20201220115945896.png" alt=""><img src="/images/typora/image-20201220133458644.png" style="zoom:80%;"></p><p>When CLK = 0</p><ul><li>L1 is transparent</li><li>L2 is opaque</li><li>D passes through N1</li></ul><p>When CLK = 1</p><ul><li>L1 is opaque</li><li>L2 is transparent</li><li>N1 passes through to Q</li></ul><p><em><strong>THUS,</strong></em> on the edge of the clock (when CLK rises from 0 to1 ), <strong>D passes through to Q.</strong></p><h3 id="Registers">Registers</h3><img src="/images/typora/image-20201220133216997.png" style="zoom: 80%;"><h3 id="Enabled-Flip-Flops">Enabled Flip-Flops</h3><p>Inputs: CLK , D,  EN</p><ul><li>EN = 1 : D passes through to Q on the clock edge</li><li>EN = 0 : the flip-flop remains its previous state</li></ul><img src="/images/typora/image-20201220133922296.png" style="zoom:67%;"><h3 id="Resettable-Flip-Flops">Resettable Flip-Flops</h3><p>Two types:</p><ol><li>Synchronous : resets at the edge only</li><li>Asynchronous : resets immediately when Reset = 1</li></ol><img src="/images/typora/image-20201220134149237.png" style="zoom:80%;"><h3 id="Settable-Flip-Flops">Settable Flip-Flops</h3><p>Inputs : CLK, D, Set</p><ul><li>Set = 1 : Q is set to 1</li><li>Set = 0: the flip-flop behaves as ordinary D flip-flop</li><li><img src="/images/typora/image-20201220134428911.png" style="zoom:80%;"></li></ul><h2 id="Synchronous-Sequential-Logic-Design">Synchronous Sequential Logic Design</h2><p>Rules of synchronous sequential circuit:</p><ul><li>Every circuit element is either a register or a combinational circuit</li><li>At least one circuit element is a register</li><li>All registers receive the same clock signal</li><li>Every cyclic path contains at least one register</li></ul><p><strong>Two common synchronous sequential circuits</strong></p><ol><li>Finite State Machines (FSMs)</li><li>Pipelines</li></ol><h3 id="Finite-State-Machine-FSM">Finite State Machine (FSM)</h3><h4 id="Consists-of">Consists of:</h4><ul><li><strong>State Register</strong></li></ul><img src="/images/typora/image-20201220141320417.png" style="zoom: 67%;"><ul><li><strong>Combinational Logic</strong></li></ul><img src="/images/typora/image-20201220141423300.png" style="zoom:67%;"><h4 id="Types">Types</h4><ul><li>Moore FSM : Outputs depend only on current state</li><li>Mealy FSM : Outputs depend on current state and inputs</li></ul><p><img src="/images/typora/image-20201220141642470.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 1（Digital Design and Computer Architecture）</title>
      <link href="/2022/02/17/computerComposit/Chapter%201/"/>
      <url>/2022/02/17/computerComposit/Chapter%201/</url>
      
        <content type="html"><![CDATA[<h1><em>Chapter 1</em></h1><p><strong>generations of computer</strong></p><ol><li>Vacuum Tubes</li><li>Transistors</li><li>SSI/MSI circuits</li><li>LSI/VLSI circuit</li></ol><p><strong>Components of CPU</strong></p><ol><li>Register</li><li>Control Unit</li><li>ALU (Arithmetic Logic Unit)</li></ol><p><strong>Components of hardware</strong></p><ol><li>calculator</li><li>memory</li><li>controller</li><li>I/O devices</li></ol><p>BASIC FEATURE of Von Neumann : access memory by address and execute instruction in sequence</p><p>The operating system is appeared <code>in the 3rd generation computers</code></p><p>Computer hardware consists of <strong>calculator</strong>, <strong>memory</strong>, <strong>controller</strong> and <strong>I/O device</strong>s.</p><p>System program: <strong>operating system</strong>, <strong>compiler</strong>, or <strong>utility program</strong></p><p><strong>machine language</strong> and <strong>assembly language</strong> can  be  implemented directly</p><h2 id="The-Art-of-Managing-Complexity">The Art of Managing Complexity</h2><ul><li><p>Abstraction</p></li><li><p>Discipline</p></li><li><p>The Three-Y’s</p><p>–Hierarchy</p><p>–Modularity</p><p>–Regularity</p></li></ul><h3 id="Abstraction">Abstraction</h3><ul><li>Hiding unimportant details</li><li>Professionals handle professional issues</li></ul><h3 id="Discipline">Discipline</h3><p>Intentionally restrict for design choices</p><h3 id="The-Three-Y’s">The Three-Y’s</h3><ul><li><p>Hierarchy(层次化)</p><p>A system divided into modules</p></li><li><p>Modularity(模块化)</p><p>Having well-defined functions and interfaces</p></li><li><p>Regularity(规整化)</p><p>Encouraging uniformity, so modules can be easily reused</p></li></ul><h2 id="The-Digital-Abstraction">The Digital Abstraction</h2><p>Digital abstraction considers <strong>discrete subset</strong> of values.</p><ul><li><strong>Focus on 0 and 1</strong></li><li><strong>Ignore physical meanings</strong></li><li><strong>make low level abstraction</strong></li></ul><p><strong>The Analytical Engine</strong></p><ul><li>Charles Babbage</li><li>first digital computer</li><li>Built from mechanical gears, where each gear represented a discrete value (0-9)</li><li>Babbage died before it was finished</li></ul><h2 id="Number-Systems">Number Systems</h2><h3 id="Decimal-numbers">Decimal numbers</h3><p>小数的表示</p><p><img src="/images/typora/image-20201122190323747.png" alt=""></p><h3 id="Binary-numbers">Binary numbers</h3><p><img src="/images/typora/image-20201122190409629.png" alt=""></p><h3 id="Hexadecimal-numbers">Hexadecimal numbers</h3><p>(0～15) ：0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</p><h3 id="Conversion">Conversion</h3><img src="/images/typora/image-20201122190601928.png" style="zoom: 80%;"><img src="/images/typora/image-20201122191216786.png" style="zoom:80%;"><h3 id="Bits-Bytes-Nibbles">Bits, Bytes, Nibbles</h3><img src="/images/typora/image-20201122191543814.png" style="zoom:50%;"><p><img src="/images/typora/image-20201122191557343.png" alt=""></p><p><img src="/images/typora/image-20201122191607427.png" alt=""></p><h3 id="Overflow">Overflow</h3><p>Overflow judgement</p><p><img src="/images/typora/image-20201122192213768.png" alt=""></p><ul><li><p>SA  SB   Sf</p><img src="/images/typora/image-20201122192125620.png" style="zoom:67%;"></li><li><p>Cf  C</p><img src="/images/typora/image-20201122192315070.png" style="zoom:67%;"></li><li><p>double sign bit</p><img src="/images/typora/image-20201122192752640.png" style="zoom:67%;"></li></ul><h3 id="Data-types">Data types</h3><p><img src="/images/typora/image-20201122201531696.png" alt=""></p><p><img src="/images/typora/image-20201122192856471.png" alt=""></p><h4 id="Signed-Binary-Numbers">Signed Binary Numbers</h4><p>•‘0’ for positive number</p><p>•‘1’ for negative number</p><p>•A separate sign bit is placed at msb position</p><h4 id="Sign-Magnitude-Numbers（原码）"><strong>Sign-Magnitude Numbers（原码）</strong></h4><p>+6 =0110</p><p>-6 =1110</p><ul><li><p><strong>Addition doesn’t work!!!</strong></p></li><li><p><strong>Two representations of 0 (± 0)</strong></p></li></ul><p>Range : <img src="/images/typora/image-20201122193551906.png" alt=""></p><h4 id="Two’s-Complement-Numbers（补码）"><strong>Two’s Complement Numbers（补码）</strong></h4><p>The most significant bit still indicates the sign (1 = negative, 0 = positive)</p><p>Range:  <img src="/images/typora/image-20201122194459726.png" style="zoom:80%;"></p><p><strong>How to flip the sign?</strong></p><p>1.Invert the bits</p><p>2.Add 1</p><img src="/images/typora/image-20201122194733530.png" style="zoom:67%;"><p>补码转换成原码：首位是1，符号位不变，后面的取反之后加一；首位是0，不变</p><h4 id="One’s-complement-representation-反码）">One’s complement representation(反码）</h4><p>正数的反码是它本身，负数的反码符号位不变，其余取反</p><h3 id="Increasing-Bit-Width">Increasing Bit Width</h3><h4 id="Sign-Extension">Sign-Extension</h4><p>•Sign bit copied to msb’s</p><p>•Number value is same</p><p><strong>Example</strong></p><img src="/images/typora/image-20201122201232411.png" style="zoom:80%;"><h4 id="Zero-Extension">Zero-Extension</h4><p>•Zeros copied to msb’s</p><p>•Value changes for negative numbers</p><img src="/images/typora/image-20201122201347957.png" style="zoom:80%;"><h2 id="Logic-Gates">Logic Gates</h2><h3 id="Single-Input-Logic-Gates">Single-Input Logic Gates</h3><img src="/images/typora/image-20201122203139777.png" style="zoom:67%;"><h3 id="Two-Input-Logic-Gates">Two-Input Logic Gates</h3><img src="/images/typora/image-20201122203159232.png" style="zoom:67%;"><img src="/images/typora/image-20201122203518772.png" style="zoom: 80%;">]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 2（Digital Design and Computer Architecture）</title>
      <link href="/2022/02/02/computerComposit/Chapter%202/"/>
      <url>/2022/02/02/computerComposit/Chapter%202/</url>
      
        <content type="html"><![CDATA[<h1><em><strong>Chapter 2</strong></em></h1><h2 id="Logic-circuit">Logic circuit</h2><h3 id="Composition">Composition</h3><ul><li>Inputs</li><li>Outputs</li><li>Functional specification</li><li>Timing specification</li></ul><h3 id="Types">Types</h3><ul><li><p>Combinational Logic</p><p>Memoryless</p><p>Output determined by current values of inputs</p><p><strong>Rules of combinational composition</strong></p><ol><li>Every element is combinational</li><li>Every node is either an input / connect to 1 output</li><li>no cyclic paths</li><li><img src="/images/typora/image-20201210161528060.png" alt=""></li></ol></li><li><p>Sequential Logic</p><p>Has memory</p><p>Output determined by previous and current values</p></li></ul><h2 id="Boolean-Equations">Boolean Equations</h2><h3 id="Definitions">Definitions</h3><p>Complement : <img src="/images/typora/image-20201210161904547.png" style="zoom: 50%;"></p><p>Literal: <img src="/images/typora/image-20201210162005476.png" style="zoom:50%;"></p><p>Implicant: <img src="/images/typora/image-20201210162024079.png" style="zoom:50%;"></p><p>Minterm: product that includes all input variables <img src="/images/typora/image-20201210162049424.png" style="zoom:50%;"></p><p>Sum: the OR of one or more literals</p><p>Maxterm: sum that includes all input variables<img src="/images/typora/image-20201210162121859.png" style="zoom:50%;"></p><h3 id="Sum-of-Products-SOP-Form">Sum-of-Products (SOP) Form</h3><p>All equations can be written in SOP form</p><img src="/images/typora/image-20201210162432695.png" style="zoom: 80%;"><h3 id="Product-of-Sums-POS-Form">Product-of-Sums (POS) Form</h3><p>All Boolean equations can be written in POS form</p><img src="/images/typora/image-20201210162544911.png" style="zoom:80%;"><h2 id="Boolean-Algebra">Boolean Algebra</h2><p><img src="/images/typora/image-20201210162955001.png" alt=""></p><p><img src="/images/typora/image-20201210163106112.png" alt=""></p><h3 id="Bubble-pushing">Bubble pushing</h3><img src="/images/typora/image-20201210163306951.png" style="zoom: 67%;"><h2 id="From-Logic-To-Gates">From Logic To Gates</h2><h3 id="Two-level-logic">Two-level logic</h3><p>ANDs followed by ORs</p><img src="/images/typora/image-20201210163643554.png" style="zoom: 67%;"><h3 id="Multiple-output-circuits">Multiple output circuits</h3><img src="/images/typora/image-20201210163815965.png" style="zoom:67%;"><p><img src="/images/typora/image-20201210163900712.png" alt=""></p><p>A3&gt;A2&gt;A1&gt;A0</p><h3 id="Don’t-cares">Don’t cares</h3><img src="/images/typora/image-20201210164023409.png" style="zoom:80%;"><h2 id="X’s-and-Z’s-Oh-My">X’s and Z’s, Oh My</h2><h3 id="Unknown-or-Illegal-X">Unknown or Illegal : X</h3><p>– Actual value somewhere in between</p><p>– Could be 0, 1, or in forbidden zone</p><p>• Warnings: – Contention usually indicates a bug.</p><p>​                      – X is used for “don’t care” and contention</p><h3 id="Floating-Z">Floating : Z</h3><p>Floating output might be 0, 1, or somewhere in between.</p><img src="/images/typora/image-20201210165411190.png" style="zoom: 67%;"><h3 id="Tristate-Buses">Tristate Buses</h3><p>Many different drivers</p><p>Exactly one is active at once</p><p><img src="/images/typora/image-20201210165838487.png" alt=""></p><h2 id="Karnaugh-Maps">Karnaugh Maps</h2><img src="/images/typora/image-20201210194218708.png" style="zoom:80%;"><img src="/images/typora/image-20201210194735943.png" style="zoom: 67%;"><h3 id="K-Map-Rules">K-Map Rules</h3><ul><li>Every 1 must be circled at least once</li><li>Each circle must be as large as possible</li><li>Each circle must span a power of 2 squares in each direction</li><li>A circle may wrap around the edges</li><li>A X is circled only if it helps minimize the equation</li></ul><h2 id="Combinational-Building-Blocks">Combinational Building Blocks</h2><h3 id="Multiplexers">Multiplexers</h3><img src="/images/typora/image-20201211160743998.png" style="zoom:80%;"><h4 id="Implementations">Implementations</h4><ul><li><p>Logic gates</p><p><img src="/images/typora/image-20201211162015150.png" alt=""></p></li><li><p>Tristates</p><p><img src="/images/typora/image-20201211162037014.png" alt=""></p></li></ul><h4 id="4：1-Multiplexers">4：1 Multiplexers</h4><p><img src="/images/typora/image-20201211164250096.png" alt=""></p><h4 id="Reducing-the-size-of-multiplexers">Reducing the size of multiplexers</h4><img src="/images/typora/image-20201211165044269.png" style="zoom:80%;"><img src="/images/typora/image-20201211165235195.png" style="zoom:80%;"><h3 id="Decoders">Decoders</h3><p><strong>One-hot outputs</strong> : Only one output <strong>HIGH</strong> at once</p><p><img src="/images/typora/image-20201211165851669.png" alt=""></p><p>Decoder Implementation</p><img src="/images/typora/image-20201211165922842.png" style="zoom:80%;"><p>OR minterms</p><img src="/images/typora/image-20201211170415162.png" style="zoom:80%;"><h2 id="Timing">Timing</h2><h3 id="Propagation-Contamination-Delay">Propagation &amp; Contamination Delay</h3><ul><li><strong>Propagation delay</strong>（传输延迟）: <img src="/images/typora/image-20201211171024639.png" style="zoom: 67%;"></li><li><strong>Contamination delay</strong>（最小延迟）: <img src="/images/typora/image-20201211171121679.png" style="zoom:67%;"><strong>output</strong></li></ul><h3 id="Cause-of-delay">Cause of delay</h3><p>Capacitance and resistance in a circuit</p><p>Speed of light limitation</p><p>• Reasons why tpd and tcd may be different:</p><p>– Different rising and falling delays</p><p>– Multiple inputs and outputs, some of which are faster than others</p><p>– Circuits slow down when hot and speed up when cold</p><h3 id="Critical-Long-Short-Paths">Critical (Long) &amp; Short Paths</h3><img src="/images/typora/image-20201211171450910.png" style="zoom:80%;"><h3 id="Glitch">Glitch</h3><img src="/images/typora/image-20201211171933590.png" style="zoom:80%;"><h3 id="Fixing-the-glitch">Fixing the glitch</h3><img src="/images/typora/image-20201211172041456.png" style="zoom:80%;">]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 5: Design</title>
      <link href="/2022/01/25/srad/srad-c5/"/>
      <url>/2022/01/25/srad/srad-c5/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Design"><em>Chapter 5</em>     Design</h2><h3 id="Advanced-class-modeling">Advanced class modeling</h3><h4 id="Stereotypes">Stereotypes</h4><p>Extends an existing UML modeling element</p><p><strong>Stereotypes</strong> are the main extensibility technique of UML. In the extensibility task, they are assisted by <strong>constraints</strong> and <strong>tags</strong></p><h4 id="Comments-and-constraints">Comments and constraints</h4><img src="/images/typora/image-20210103100659961.png" style="zoom:80%;"><h3 id="Advanced-generalization-and-inheritance-modeling">Advanced generalization and inheritance modeling</h3><h4 id="Generalization-and-substitutability">Generalization and substitutability</h4><p><strong>Generalization</strong> reduces the number of <strong>association</strong> and <strong>aggregation</strong>(聚合) relationships in the model</p><p>**Substitutability principle ：**a subclass object can be used in place of a superclass object</p><h4 id="Inheritance-versus-encapsulation-封装">Inheritance versus encapsulation(封装)</h4><ul><li><p>Encapsulation</p><ul><li>Encapsulation refers to the <strong>class</strong> , not the object</li><li>Encapsulation demands that an object’s state be accessible only through the operations in the object’s interface.</li></ul></li><li><p>Implementation Inheritance</p><ul><li>Generalization can be used to imply <strong>substitutability</strong>,  and be realized by an <strong>interface inheritance</strong></li><li>Generalization can also be used to imply <strong>code reuse</strong>, and be realized by an <strong>implementation inheritance</strong></li></ul></li><li><p>The evils of implementation inheritance</p><ul><li>Fragile base class</li><li>Overriding and callbacks</li><li>multiple implementation inheritance</li></ul></li></ul><h3 id="Advanced-aggregation-and-delegation-modeling">Advanced aggregation and delegation modeling</h3><h4 id="🍓-Aggregation">🍓  <strong>Aggregation</strong></h4><p>Aggregation is a containment relationship</p><p>More <strong>semantics</strong>(语义学) needed</p><ul><li>“ExclusiveOwns” aggregation</li></ul><img src="/images/typora/image-20210103105720477.png" style="zoom:67%;"><ul><li>“Owns” aggregation</li></ul><img src="/images/typora/image-20210103105738344.png" style="zoom:67%;"><ul><li>“Has” aggregation</li></ul><img src="/images/typora/image-20210103105836747.png" style="zoom:67%;"><ul><li>“Member” aggregation</li></ul><img src="/images/typora/image-20210103105906986.png" style="zoom:67%;"><h4 id="Generalization-vs-aggregation">Generalization vs aggregation</h4><img src="/images/typora/image-20210103105950944.png" style="zoom:67%;"><h3 id="Advanced-interaction-modeling">Advanced interaction modeling</h3><p><strong>Execution specification</strong> : The time when the flow of control is focused in an object</p><p><strong>Reply message</strong>: The return result from a message</p><p><strong>Found message</strong>:  represents a message whose sender is not specified</p><h4 id="Fragments">Fragments</h4><ul><li>A piece of interaction is called an <strong>interaction fragment</strong></li><li>Interactions can contain smaller interaction fragments called <strong>combined fragments</strong></li><li>The semantics of a combined fragment is determined by the <strong>interaction operator</strong></li></ul><p>A reference to an interaction from an enclosing interaction is called an <strong>interaction use</strong>.</p><p><strong>Sequence diagrams</strong> are the preferred visual tool for interaction modeling. They can be enriched with <strong>combined fragments</strong> and <strong>interaction uses</strong>.</p>]]></content>
      
      
      <categories>
          
          <category> 软件需求分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Thomas的软需 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 4: Requirements Specification</title>
      <link href="/2022/01/08/srad/srad-c4/"/>
      <url>/2022/01/08/srad/srad-c4/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Requirements-Specification"><em>Chapter 4</em>     Requirements Specification</h2><h3 id="Architectural-prerogatives">Architectural prerogatives</h3><h4 id="Architectural-design">Architectural design</h4><h5 id="Design">Design</h5><ul><li>detailed</li><li>architectural</li></ul><h5 id="Architectural-model">Architectural model</h5><ul><li>hierarchical layers</li><li>restrictions on object inter-communications to minimize dependencies</li></ul><h5 id="MVC">MVC</h5><ul><li>Model : represent data objects</li><li>View : represent user interface(UI) objects</li><li>Controller: represent mouse and keyboard events</li></ul><h5 id="J2EE">J2EE</h5><ul><li>The users communicates with the system from the <strong>client server</strong></li><li><strong>EIS tier</strong>(also called <strong>Resource tier</strong>) is any persistent(持久性) information delivery system</li><li>The users access the application via the <strong>Presentation tier</strong> (<strong>Web tier</strong>)</li><li><strong>Business tier</strong> contains application logic</li><li><strong>Integration tier</strong> establishes and maintains(维护) connections to data sources</li></ul><h5 id="The-Core-PCBMER-framework">The Core PCBMER framework</h5><p><strong>Presentation</strong> represents the screen and UI objects</p><p><strong>Bean</strong> represents the data classes and value objects</p><p><strong>Controller</strong> represents the application logic</p><p><strong>Entity</strong> contains classes representing business objects</p><p><strong>Mediator</strong> manages business transactions, enforces business rules, instantiates business objects in the Entity layer, and in general manages the memory cache of the application</p><p><strong>Resource</strong> is responsible for all communication with external persistent data sources</p><img src="/images/typora/image-20210101223825823.png" style="zoom:67%;"><h5 id="Architectural-principles">Architectural principles</h5><p><strong>DDP</strong> – downward dependency principle</p><ul><li>Higher PCBMER layers depend on lower layers</li><li>lower layers should be designed to be more stable</li></ul><p><strong>UNP</strong> – upward notification principle</p><ul><li>Upward communication that minimize object dependencies</li><li>Lower layers rely on interfaces and event processing to communicate with objects in higher layers</li></ul><p><strong>NCP</strong> – neighbor communication principle</p><ul><li>Objects can communicate across layers only by using direct neighbors</li><li>chains of message passing</li></ul><p><strong>APP</strong> – acquaintance(熟人) package principle</p><p><strong>EAP</strong> – explicit(显式的) association principle</p><p><strong>CEP</strong> – cycle elimination(淘汰) principle</p><p><strong>CNP</strong> – class naming principle</p><h3 id="State-Specifications">State Specifications</h3><ul><li>Model of data structures</li><li>Static view on the system</li><li>Class operations left out in initial specs</li><li>Emphasis on entity classes (‘business objects’)</li></ul><h4 id="Modeling-classes">Modeling classes</h4><ul><li>Cornerstone(基石) of OO development</li><li>Iterative and  incremental process</li><li>Case tool<ul><li>For collaborative development</li><li>For personal productivity otherwise</li></ul></li></ul><h4 id="Discovering-classes">Discovering classes</h4><ul><li>Noun phrase</li><li>Common class patterns<ul><li>From candidate classes from the classification theory of objects</li><li>😢 Only loosely bound to user requirements</li><li>😢  Possible naming misinterpretations(命名误解)</li></ul></li><li>Use case driven<ul><li>Function driven</li><li>Relies on the completeness of use case models</li></ul></li><li>CRC<ul><li>class, responsibilities,collaborators</li></ul></li><li>Mixed<ul><li>Use elements of all four previous approaches</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件需求分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Thomas的软需 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 3: Modeling</title>
      <link href="/2021/12/25/srad/srad-c3/"/>
      <url>/2021/12/25/srad/srad-c3/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-3-Modeling"><em>Chapter 3</em> Modeling</h2><h3 id="Abstraction-Modeling">Abstraction &amp; Modeling</h3><h4 id="Abstraction">Abstraction</h4><ul><li>Abstractions allow us to ignore unessential details</li><li>2 definitions for abstraction<ul><li><strong>Abstraction as activity:</strong> Abstraction is a <strong>throughout process</strong> where ideas are distanced from objects</li><li><strong>Abstraction as entity:</strong> Abstraction is the <strong>resulting idea</strong> of a throughout process where an idea has been distanced from an object</li></ul></li></ul><p>🍰  Ideas can be expressed by models</p><h4 id="Models">Models</h4><ul><li>Object model</li><li>Functional model</li><li>Dynamic model</li><li>System model</li></ul><p>Other Models</p><ul><li>Task Model</li><li>Issue Modeling</li></ul><h5 id="Decomposition">Decomposition</h5><p><strong>two types</strong></p><ul><li><strong>Functional decomposition</strong><ul><li>The system is decomposed into <strong>modules</strong></li><li><strong>Each module</strong> is a major <strong>function</strong> in the application domain</li><li>Modules can be decomposed into <strong>smaller modules</strong></li></ul></li><li><strong>Object-oriented decomposition</strong><ul><li>The system is decomposed into <strong>classes</strong></li><li><strong>Each class</strong> is a major <strong>entity</strong> in the application domain</li><li>Classes can be decomposed into <strong>smaller classes</strong></li></ul></li></ul><p>🚶  Three ways to deal with complexity</p><ul><li>Abstraction</li><li>Decomposition</li><li>Hierarchy</li></ul><p>🚶   Steps</p><ol><li>Start with a description of the functionality of a system</li><li>Then proceed to a description of its structure</li></ol><p>🚶   Order</p><ul><li>Software lifecycle</li></ul><h5 id="UML-Models">UML Models</h5><ul><li><p>Structure models (static view of the system)</p><ul><li>class diagram</li></ul></li><li><p>Behavior models  (operational view of the system)</p><ul><li>use case diagram</li><li>activity diagram</li><li>communication diagram</li></ul></li><li><p>State change models (dynamic view of the system)</p><ul><li>state machine system</li></ul></li></ul><h3 id="Use-case-view">Use case view</h3><p>Primary actors: system is designed to serve</p><p>Secondary actors: support roles</p><p>🍬  <strong>TASK</strong></p><ol><li>Identify actors</li><li>Identify initial use cases</li><li>Draw use case diagram</li><li>Identify packages</li><li>Develop initial use cases</li><li>Refine the Typical and Alternative Scenarios</li><li>Restructure use cases<ul><li>«include» relationship<ul><li>Factors out common behavior in use cases</li><li>included steps</li></ul></li><li>«extend» relationship<ul><li>Factors out optional behaviors in use cases</li><li>extended scenario</li></ul></li><li>generalization</li></ul></li></ol><h3 id="Activity-view">Activity view</h3><p>activity diagram</p><h3 id="Structure-view">Structure view</h3><p>class diagram</p><h3 id="Interaction-view">Interaction view</h3><p>sequence diagram</p><p>Communication diagram</p><h3 id="State-Machine-view">State Machine view</h3><p>state machine diagram</p><h3 id="Implementation-view">Implementation view</h3><p>Component diagram</p><p>deployment diagram</p>]]></content>
      
      
      <categories>
          
          <category> 软件需求分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Thomas的软需 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 2: Requirements Determination</title>
      <link href="/2021/11/15/srad/srad-c2/"/>
      <url>/2021/11/15/srad/srad-c2/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Requirements-Determination"><em>Chapter 2</em>     Requirements Determination</h2><h3 id="🍕From-business-process-to-solution-envisioning">🍕From business process to solution envisioning</h3><h4 id="IT-Solution">IT Solution</h4><ul><li>Implementation of a <strong>business process</strong></li></ul><h5 id="BPMN">BPMN</h5><p>Business Process Modeling Notation</p><p>UML <strong>activity diagrams</strong></p><p>Goal: Map these notations to an executable language</p><h5 id="BPMN-categories-of-modeling-events">BPMN categories of modeling events</h5><ol><li>Flow objects<ul><li>Events</li><li>Activities</li><li>Gateways</li></ul></li><li>Connecting objects</li></ol><p>&lt;img src="/images/typora/image-20201229204732957.png"style=“zoom:80%;” /&gt;</p><ol start="3"><li><p>Pools (Swim lanes)</p><p>A pool represents a business entity (participant) in a process.</p><p>❗️ <strong>the sequence flow may not cross the boundary of a pool</strong></p></li><li><p>Artifacts</p></li></ol><h5 id="Process-hierarchy-modeling">Process hierarchy modeling</h5><ul><li><p><strong>sub-processes</strong></p><p>A process may contain other processes</p></li><li><p><strong>task</strong></p><p>An atomic activity within a process</p></li><li><p><strong>process hierarchy(等级制) diagram</strong></p><ul><li>A business process can be performed <strong>manually</strong> or <strong>an automated service</strong></li><li>A process has at least one <strong>input</strong> flow and one <strong>output</strong> flow</li><li>A process can be atomic or composite</li><li><img src="/images/typora/image-20201229204308773.png" style="zoom:67%;"></li></ul></li></ul><h4 id="Solution-envisioning">Solution envisioning</h4><ul><li><p>a <strong>business value-driven approach</strong> to delivering an IT service</p></li><li><p>makes a close <strong>connection</strong> between business and IT stakeholders and  <strong>integrates</strong>(整合) business strategy methods and software development capabilities.</p></li><li><p>Three “E-s” (efficiency, effectiveness, and edge)</p></li><li><p><strong>Three phases</strong></p><ul><li>Business capability exploration</li><li>Solution capability envisioning</li><li>Software capability design (outcome : software capability architecture)</li></ul></li><li><p><strong>Three distinct implementation strategies</strong></p></li></ul><ol><li>Custom development</li><li>Package-based development</li><li>Component-based development</li></ol><h3 id="🍕Requirements-Engineering">🍕Requirements Engineering</h3><h4 id="Products">Products</h4><p><strong>Primary outcome</strong> is a requirements specification</p><p><strong>Secondary outcome</strong> is a usually system and software acceptance test criteria</p><h4 id="Why-is-RE-important">Why is RE important</h4><ul><li>Helps earlier detection of mistakes</li><li>Forces clients to articulate and review requirements</li><li>Enhance communications between participations</li></ul><h4 id="What-happens-if-Requirements-are-wrong">What happens if Requirements are wrong</h4><ul><li>System may be delivered late and cost more.</li><li>Customers and end-users are not satisfied</li><li>System may be unreliable in use</li></ul><h4 id="Functional-Requirements">Functional Requirements</h4><ul><li>Requirements (or capabilities) for functions <strong>must be performed by the system</strong></li><li><strong>Primary focus</strong> of most requirements activities</li></ul><h4 id="Non-Functional-Requirements">Non-Functional Requirements</h4><ul><li><strong>System properties and constraints</strong></li><li><strong>More critical</strong> than functional requirements</li><li>NFR Sources<ul><li>Product requirements</li><li>Process requirements</li><li>External requirements</li></ul></li></ul><h4 id="Verifiable">Verifiable</h4><p>❗️  <strong>Imprecise requirements cannot be verified</strong></p><p>NFR should be a <strong>measurable</strong> statement</p><h4 id="Requirements-Engineering-Process">Requirements Engineering Process</h4><ul><li>Requirements Elicitation（启发） and Analysis</li><li>Requirements Specification</li><li>Requirements Validation(验证方式)</li><li>Requirements Management</li></ul><h3 id="🍕-Requirements-Elicitation">🍕  Requirements Elicitation</h3><h4 id="Requirements-elicitation-principles">Requirements elicitation principles</h4><p>System development is motivated by <strong>a problem</strong></p><ul><li>Aim: to understand the problem clearly</li></ul><h4 id="Requirements-elicitation-activities">Requirements elicitation activities</h4><ul><li><strong>Analyzing the problem</strong></li><li><strong>Identifying requirements sources</strong></li><li><strong>Eliciting requirements from these sources</strong></li></ul><h4 id="Requirements-elicitation-techniques">Requirements elicitation techniques</h4><ul><li>Challenges<ul><li>Stakeholders and users may not be able to describe their tasks well</li><li>Requirements conflict</li><li>Implicit（隐式） requirements</li></ul></li></ul><h5 id="Interviews">Interviews</h5><ul><li>Prepare questions in advance</li><li>Suggest ideas &amp; alternatives</li></ul><h5 id="Workshops">Workshops</h5><ul><li>Structured meeting<ul><li>formal roles</li><li>clear goals</li></ul></li><li>Multiple stakeholders<ul><li>resolve conflicting requirements</li><li>gather board system usage</li></ul></li></ul><h5 id="Focus-Groups">Focus Groups</h5><ul><li>Less structure</li><li>Exploratory(探索性) discussion</li><li>Broad stakeholder representation</li><li>Gather broad-based ideas</li></ul><h5 id="Observations">Observations</h5><ul><li>Observe how users perform their tasks</li><li>Users often cannot describe everything they do</li><li>Time consuming</li></ul><h5 id="Questionnaires">Questionnaires</h5><ul><li>Inexpensive and easily administered to remote sites</li><li>Collect data from many users</li><li>May feed into interviews or workshops</li><li>😢  Good questionnaires difficult to write</li><li>🍰   <strong>Good Questionnaire</strong><ul><li>Answer options for all possibilities</li><li>Answer choices mutually exclusive(互斥)</li><li>Avoid phrasing that implies a correct answer</li><li>Closed questions for statistical analysis</li><li>Open questions to gather ideas</li><li>Short</li></ul></li></ul><h5 id="Independent-Elicitation-Techniques">Independent Elicitation Techniques</h5><h6 id="Discover-information-on-your-own">Discover information on your own</h6><h6 id="System-interface-analysis">System interface analysis</h6><ul><li>Look at other systems’ functionality</li><li>Data exchange (including formats &amp; validation(验证) rules)</li><li>Services</li></ul><h6 id="User-interface-analysis">User interface analysis</h6><ul><li>Study existing systems</li></ul><h6 id="Document-analysis">Document analysis</h6><ul><li>Business process descriptions</li><li>Existing system documentation</li><li>Industry standards or legislation</li><li>Gain understanding of domain or system</li></ul><h4 id="Product-of-elicitation-phase">Product of elicitation phase</h4><ul><li>Requirements documentation including a requirements definition</li><li>May use pre-defined requirements document template<ul><li>IEEE, ISO,…</li></ul></li><li>May use less formal documentation and tools<ul><li>User Stories, Jira…</li></ul></li></ul><h3 id="🍕-Requirements-negotiation-and-validation">🍕  Requirements negotiation and validation</h3><p><strong>Frequently done in parallel with requirements elicitation</strong></p><p>📁  Inseparable from the production of requirements document</p><ul><li>negotiation starts from the draft requirement doc</li><li>validation reviews and approves the doc</li></ul><p>🌵  <strong>Requirements dependency matrix</strong></p><ul><li><strong>Conflict &amp; Overlap</strong></li></ul><h4 id="Requirements-risks-and-priorities">Requirements risks and priorities</h4><ul><li><strong>Risk analysis</strong> identifies requirements that are likely to cause development difficulties</li><li><strong>Prioritization</strong>(优先次序) allows easy re-scoping of the project when faced with delays</li></ul><h5 id="Risk-Categories">Risk Categories</h5><ol><li>Technical</li><li>Performance</li><li>Security</li><li>Database integrity(数据库完整性)</li><li>Development process</li><li>Political</li><li>Legal</li><li>Volatility （挥发性）</li></ol><h4 id="Requirements-Management">Requirements Management</h4><h5 id="Requirements-identification-and-classification">Requirements identification and classification</h5><ul><li>Natural language statements</li><li>Identification and classification scheme<ul><li>Unique identifier</li><li>Sequential number with document hierarchy （文件等级制）</li><li>Sequential number with requirement’s category (需求类别)</li></ul></li></ul><h5 id="Requirements-hierarchies">Requirements hierarchies</h5><p>🍼  <strong>Parent-child relationships</strong></p><p>Reflect varying abstraction levels</p><ol><li><p>…</p><p>1.1…</p><p>1.2…</p><p>1.3…</p></li></ol><h5 id="Change-management">Change management</h5><p><em><strong>Downstream cost</strong></em> of change</p><ul><li>Strong management policies<ul><li>document change requests</li><li>assess change impact</li><li>effect the changes</li></ul></li></ul><p>⚠️  Requirements changes should be stored and tracked by a <strong>software configuration management tool</strong></p><h5 id="Requirements-traceability">Requirements traceability</h5><p><strong>suspect trace</strong>  :  After change to any element in a traceability relationship</p><h4 id="Requirements-business-model">Requirements business model</h4><p><strong>Context diagram</strong>  (System scope)</p><img src="/images/typora/image-20201230151710736.png" style="zoom:67%;"><p><strong>Business Use case diagram</strong>(function requirements)</p><img src="/images/typora/image-20201230151455098.png" alt="" style="zoom:67%;"><p><strong>Business class diagram</strong>  (data requirements)</p><img src="/images/typora/image-20201230151522214.png" alt="" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 软件需求分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Thomas的软需 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 1: Process Models</title>
      <link href="/2021/10/14/srad/srad-c1/"/>
      <url>/2021/10/14/srad/srad-c1/</url>
      
        <content type="html"><![CDATA[<h1><strong>🍕 <em><strong>Chapter 1</strong></em>   Process Models</strong></h1><p>Abstract representation of a process</p><h3 id="😶Waterfall-plan-driven">😶<strong>Waterfall</strong> (plan driven)</h3><p>💡  Introduce iteration between phases<br><img src="/images/waterfall.png" alt="Waterfall Model" style="zoom: 67%;"></p><h3 id="😶V-Model-plan-driven">😶<strong>V  Model</strong> (plan driven)</h3><img src="/images/typora/image-20201226160400440.png" alt="V Model" style="zoom:67%;"><h3 id="😶Spiral-plan-driven">😶<strong>Spiral</strong> (plan driven)</h3><p>💡  <strong>Focus on process control​</strong><br>❗️   introduce <strong>risk analysis</strong> so that the software has the opportunity to stop when major risks can’t be ruled out . It reduces loss.</p><p><strong>Application</strong></p><ul><li>When there is a budget constraint and <strong>risk evaluation</strong> is important.</li><li>Requirements are complex and need evaluation to get clarity.</li></ul><img src="/images/typora/image-20201226161836684.png" style="zoom:80%;"><h3 id="⭐️Incremental-and-Iterative-Process-Model">⭐️<strong>Incremental and Iterative Process Model</strong></h3><p>Details are added in successive <strong>iterations</strong>, changes and improvements are introduced as needed and <strong>incremental</strong> releases of software modules maintain user satisfaction and provide important feedback to modules still under development.</p><h3 id="⭐️Unified-Process-Model">⭐️<strong>Unified Process Model</strong></h3><p>💡  Four distinct phases</p><ol><li>Inception</li><li>Elaboration（细化）</li><li>Construction</li><li>Transition（过渡）<br>💡  Characteristics</li></ol><ul><li>use-case driven</li><li>architecture-centric</li><li>risk focused</li><li>iterative and incremental</li><li><img src="/images/typora/image-20201226174534551.png" style="zoom:67%;"></li></ul><h3 id="⭐️Model-Driven-Architecture-MDA-Model">⭐️<strong>Model Driven Architecture (MDA)  Model</strong></h3><p>MDA is based on the idea of executable specifications – generating the software from models and components.</p><h3 id="⭐️Agile-Model">⭐️<strong>Agile Model</strong></h3><p>Agile development proposes a framework in which people and team <strong>collaboration</strong> are considered more important than <strong>planning</strong>, documentation and other formalities.</p><p>❗️  Requirements are never changed!</p><p>❗️   Deliver early and deliver often !</p><p>💙 Agile methods:  <strong>Scrum</strong>, XP, FDD, DSDM</p><p><strong>Scrum</strong> : Scrum is a simple framework for effective team collaboration <strong>on complex products</strong>. It productively and creatively delivers products of the <strong>highest possible value.</strong></p><ul><li>Lightweight</li><li>Simple to understand</li><li>Difficult to master</li></ul><h3 id="⭐️Lean-Development-Model">⭐️<strong>Lean Development Model</strong></h3><p>💚  a set of principles that can be applied to software development to decrease programming effort , budgeting, and  defect rates by one third</p><ul><li>Think Big</li><li>Act Small</li><li>Fail Fast</li></ul><p>💡   <strong>Principles</strong></p><ul><li>Eliminate Waste （消除浪费）</li><li>Amplify Learning  (加强学习)</li><li>Decide as late as possible</li><li>Deliver as Fast as Possible</li><li>Empower the team</li><li>Build Integrity(廉洁) in</li><li>See the whole</li></ul><h3 id="⭐️Formal-Model">⭐️<strong>Formal</strong> <strong>Model</strong></h3><p><strong>A formal model is a precise statement of components to be used and the relationships among them.</strong></p><p>💡  Application of mathematical formality to software development</p><ul><li>formal specification</li><li>transformation of specification to code</li></ul><h3 id="⭐️-Z-specification-Model">⭐️  <strong>Z specification Model</strong></h3><p>Z is a model oriented formal specification language</p><img src="/images/typora/image-20201227152620036.png" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 软件需求分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二的回忆 </tag>
            
            <tag> 2020年的冬天 </tag>
            
            <tag> 大学笔记不完全整理 </tag>
            
            <tag> Thomas的软需 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
